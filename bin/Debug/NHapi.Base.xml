<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHapi.Base</name>
    </assembly>
    <members>
        <member name="F:NHapi.Base.AcknowledgmentCode.AA">
            <summary>
            Application Accept
            </summary>
        </member>
        <member name="F:NHapi.Base.AcknowledgmentCode.AE">
            <summary>
            Application Error
            </summary>
        </member>
        <member name="F:NHapi.Base.AcknowledgmentCode.AR">
            <summary>
            Application Reject
            </summary>
        </member>
        <member name="F:NHapi.Base.AcknowledgmentCode.CA">
            <summary>
            Commit Accept
            </summary>
        </member>
        <member name="F:NHapi.Base.AcknowledgmentCode.CE">
            <summary>
            Commit Error
            </summary>
        </member>
        <member name="F:NHapi.Base.AcknowledgmentCode.CR">
            <summary>
            Commit Reject
            </summary>
        </member>
        <member name="T:NHapi.Base.DataTypeException">
            <summary> Represents a problem with the validity of a data type, such as an attempt
            to set the value of a primitive type to something invalid for that type.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String,System.Int32,System.Exception)">
            <param name="message">
            </param>
            <param name="errorCondition">
            </param>
            <param name="cause">
            </param>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String,NHapi.Base.ErrorCode,System.Exception)">
            <param name="message">
            </param>
            <param name="errorCondition">
            </param>
            <param name="cause">
            </param>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String,System.Int32)">
            <param name="message">
            </param>
            <param name="errorCondition">
            </param>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String,NHapi.Base.ErrorCode)">
            <param name="message">
            </param>
            <param name="errorCondition">
            </param>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String,System.Exception)">
            <param name="message">
            </param>
            <param name="cause">
            </param>
        </member>
        <member name="M:NHapi.Base.DataTypeException.#ctor(System.String)">
            <param name="message">
            </param>
        </member>
        <member name="F:NHapi.Base.ErrorCode.MESSAGE_ACCEPTED">
            <summary>
            Message accepted
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.SEGMENT_SEQUENCE_ERROR">
            <summary>
            Segment sequence error
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.REQUIRED_FIELD_MISSING">
            <summary>
            Required field missing
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.DATA_TYPE_ERROR">
            <summary>
            Date type error
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.TABLE_VALUE_NOT_FOUND">
            <summary>
            Table value not found
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.UNSUPPORTED_MESSAGE_TYPE">
            <summary>
            Unsupported message type
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.UNSUPPORTED_EVENT_CODE">
            <summary>
            Unsupported event code
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.UNSUPPORTED_PROCESSING_ID">
            <summary>
            Unsupported processing id
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.UNSUPPORTED_VERSION_ID">
            <summary>
            Unsupported version id
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.UNKNOWN_KEY_IDENTIFIER">
            <summary>
            Unknown key id
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.DUPLICATE_KEY_IDENTIFIER">
            <summary>
            Duplicate key id
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.APPLICATION_RECORD_LOCKED">
            <summary>
            Application record locked
            </summary>
        </member>
        <member name="F:NHapi.Base.ErrorCode.APPLICATION_INTERNAL_ERROR">
            <summary>
            Application error
            </summary>
        </member>
        <member name="M:NHapi.Base.ErrorCodeExtensions.ToErrorCode(System.Int32)">
            <summary>
            Returns the ErrorCode for the given integer.
            </summary>
            <param name="errorCode">integer error code.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">when given integer is not a valid <see cref="T:NHapi.Base.ErrorCode"/> value.</exception>
        </member>
        <member name="M:NHapi.Base.ErrorCodeExtensions.GetCode(NHapi.Base.ErrorCode)">
            <summary>
            Get the integer error code for the <see cref="T:NHapi.Base.ErrorCode"/>.
            </summary>
            <param name="errorCode"></param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.ErrorCodeExtensions.GetName(NHapi.Base.ErrorCode)">
            <summary>
            Retrieves the name of the <see cref="T:NHapi.Base.ErrorCode"/> value
            from the <seealso cref="T:System.ComponentModel.DescriptionAttribute"/> or the string
            representation of the enum value if there is no <seealso cref="T:System.ComponentModel.DescriptionAttribute"/>
            present.
            </summary>
            <param name="errorCode">the <see cref="T:NHapi.Base.ErrorCode"/> we will retrieve the description from.</param>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.HL7Exception">
            <summary> Represents an exception encountered while processing
            an HL7 message.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="F:NHapi.Base.HL7Exception.ACK_AA">
            <summary>
            Acknowledgment Application Accept.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.AcknowledgmentCode.AA"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.ACK_AE">
            <summary>
            Acknowledgment Application Error.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.AcknowledgmentCode.AE"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.ACK_AR">
            <summary>
            Acknowledgment Application Reject.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.AcknowledgmentCode.AR"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.MESSAGE_ACCEPTED">
            <summary>
            Message accepted.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.MESSAGE_ACCEPTED"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.SEGMENT_SEQUENCE_ERROR">
            <summary>
            Segment sequence error.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.SEGMENT_SEQUENCE_ERROR"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.REQUIRED_FIELD_MISSING">
            <summary>
            Required field missing.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.REQUIRED_FIELD_MISSING"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.DATA_TYPE_ERROR">
            <summary>
            Date type error.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.DATA_TYPE_ERROR"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.TABLE_VALUE_NOT_FOUND">
            <summary>
            Table value not found.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.TABLE_VALUE_NOT_FOUND"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.UNSUPPORTED_MESSAGE_TYPE">
            <summary>
            Unsupported message type.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_MESSAGE_TYPE"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.UNSUPPORTED_EVENT_CODE">
            <summary>
            Unsupported event code.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_EVENT_CODE"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.UNSUPPORTED_PROCESSING_ID">
            <summary>
            Unsupported processing id.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_PROCESSING_ID"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.UNSUPPORTED_VERSION_ID">
            <summary>
            Unsupported version id.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_VERSION_ID"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.UNKNOWN_KEY_IDENTIFIER">
            <summary>
            Unknown key id.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.MESSAGE_ACCEPTED"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.DUPLICATE_KEY_IDENTIFIER">
            <summary>
            Duplicate key id.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.DUPLICATE_KEY_IDENTIFIER"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.APPLICATION_RECORD_LOCKED">
            <summary>
            Application record locked.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.APPLICATION_RECORD_LOCKED"/> instead.</remarks>
        </member>
        <member name="F:NHapi.Base.HL7Exception.APPLICATION_INTERNAL_ERROR">
            <summary>
            Application error.
            </summary>
            <remarks>Deprecated use <see cref="F:NHapi.Base.ErrorCode.APPLICATION_INTERNAL_ERROR"/> instead.</remarks>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String,System.Int32,System.Exception)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" />.
            <param name="message">The error message</param>
            <param name="errorCondition">a code describing the error condition, from HL7
            table 0357 (see section 2.16.8 of standard v 2.4) - <see cref="T:NHapi.Base.ErrorCode" /> defines
            these codes as integer constants that can be used here (e.g.
            <c>ErrorCode.UNSUPPORTED_MESSAGE_TYPE.GetCode()</c>)
            </param>
            <param name="cause">The exception that caused this exception to be thrown.
            </param>
            </summary>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String,NHapi.Base.ErrorCode,System.Exception)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" />.
            <param name="message">The error message</param>
            <param name="errorCondition">a code describing the error condition, from HL7
            table 0357 (see section 2.16.8 of standard v 2.4) - <see cref="T:NHapi.Base.ErrorCode"/> defines
            these codes as integer constants that can be used here (e.g.
            <seealso cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_MESSAGE_TYPE" />)
            </param>
            <param name="cause">The exception that caused this exception to be thrown.
            </param>
            </summary>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String,System.Int32)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" />.
            <param name="message">the error message</param>
            <param name="errorCondition">a code describing the error condition, from HL7
            table 0357 (see section 2.16.8 of standard v 2.4) - <see cref="T:NHapi.Base.ErrorCode"/> defines
            these codes as integer constants that can be used here (e.g.
            <c>ErrorCode.UNSUPPORTED_MESSAGE_TYPE.GetCode()</c>)
            </param>
            </summary>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String,NHapi.Base.ErrorCode)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" />.
            <param name="message">the error message</param>
            <param name="errorCondition">a code describing the error condition, from HL7
            table 0357 (see section 2.16.8 of standard v 2.4) - <see cref="T:NHapi.Base.ErrorCode"/> defines
            these codes as integer constants that can be used here (e.g.
            <seealso cref="F:NHapi.Base.ErrorCode.UNSUPPORTED_MESSAGE_TYPE" />)
            </param>
            </summary>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String,System.Exception)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" /> with the code.
            <seealso cref="F:NHapi.Base.ErrorCode.APPLICATION_INTERNAL_ERROR" />
            <param name="cause">The exception that caused this exception to be thrown.</param>
            <param name="message">the error message</param>
            </summary>
        </member>
        <member name="M:NHapi.Base.HL7Exception.#ctor(System.String)">
            <summary> Creates an <see cref="T:NHapi.Base.HL7Exception" /> with the code.
            <seealso cref="F:NHapi.Base.ErrorCode.APPLICATION_INTERNAL_ERROR" /></summary>
        </member>
        <member name="P:NHapi.Base.HL7Exception.SegmentName">
            <value>
            The name of the segment where the error occurred.
            <para>(returns null if not set).</para>
            </value>
        </member>
        <member name="P:NHapi.Base.HL7Exception.SegmentRepetition">
            <value>
            The sequence number of the segment where the error occurred (if there
            are multiple segments with the same name).
            <para> Numbering starts at 1. </para>
            <para> (returns -1 if not set). </para>
            </value>
        </member>
        <member name="P:NHapi.Base.HL7Exception.FieldPosition">
            <value>
            The field number within the segment where the error occurred.
            <para>Numbering starts at 1.</para>
            <para> (returns -1 if not set). </para>
            </value>
        </member>
        <member name="P:NHapi.Base.HL7Exception.ErrorCode">
            <value>
            The <see cref="T:NHapi.Base.ErrorCode"/> value associated with the <see cref="T:NHapi.Base.HL7Exception"/>.
            </value>
        </member>
        <member name="P:NHapi.Base.HL7Exception.Message">
            <value>
            The message that describes the current exception.
            </value>
            <remarks>Overrides <see cref="P:System.Exception.Message" /> to add
            the field location of the problem if available.</remarks>
        </member>
        <member name="M:NHapi.Base.HL7Exception.Populate(NHapi.Base.Model.ISegment)">
            <summary> Populates the given error segment with information from this Exception.</summary>
        </member>
        <member name="M:NHapi.Base.Llp.CharSetUtility.CheckCharset(System.Byte[])">
            <summary>
            Attempt to determine the HL7 character set (<see cref="T:System.Text.Encoding"/>) of the HL7 message.
            </summary>
            <param name="message">HL7 message as bytes.</param>
            <returns>The detected Hl7 character set, if none detected defaults to ASCII (us-ascii).</returns>
        </member>
        <member name="M:NHapi.Base.Llp.CharSetUtility.CheckCharset(System.Byte[],System.Text.Encoding)">
            <summary>
            Attempt to determine the HL7 character set (<see cref="T:System.Text.Encoding"/>) of the HL7 message.
            </summary>
            <param name="message">HL7 message as <see cref="T:byte[]"/>.</param>
            <param name="encoding">HL7 Character to be used should one not be detected.</param>
            <returns>The detected Hl7 character set, if none detected defaults to the one provided by the
            <paramref name="encoding"/> parameter.
            </returns>
        </member>
        <member name="M:NHapi.Base.Llp.CharSetUtility.CheckCharset(System.String)">
            <summary>
            Attempt to determine the HL7 character set (<see cref="T:System.Text.Encoding"/>) of the HL7 message.
            </summary>
            <param name="message">HL7 message as a <see cref="T:System.String"/>.</param>
            <returns>The detected Hl7 character set, if none detected defaults to ASCII (us-ascii).</returns>
        </member>
        <member name="M:NHapi.Base.Llp.CharSetUtility.CheckCharset(System.String,System.Text.Encoding)">
            <summary>
            Attempt to determine the HL7 character set (<see cref="T:System.Text.Encoding"/>) of the HL7 message.
            </summary>
            <param name="message">HL7 message as a <see cref="T:System.String"/>.</param>
            <param name="encoding">HL7 Character to be used should one not be detected.</param>
            <returns>The detected Hl7 character set, if none detected defaults to the one provided by the
            <paramref name="encoding"/> parameter.
            </returns>
        </member>
        <member name="T:NHapi.Base.Llp.Hl7CharSets">
            <summary>
            HL7 Charsets from Table 0211 mapped to dotnet <see cref="T:System.Text.Encoding"/>.
            </summary>
        </member>
        <member name="M:NHapi.Base.Llp.Hl7CharSets.FromHl7Encoding(System.String)">
            <summary>
            Returns the dotnet <see cref="T:System.Text.Encoding"/> for the HL7 charset name.
            <a href="https://learn.microsoft.com/en-us/dotnet/api/system.text.encoding#list-of-encodings">list of supported encodings</a>.
            </summary>
            <param name="hl7EncodingName"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">When null empty or white-space <paramref name="hl7EncodingName"/>.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="hl7EncodingName" /> is not a valid code page name.
            -or-
            The code page indicated by <paramref name="hl7EncodingName" /> is not supported by the underlying platform.</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException"><paramref name="hl7EncodingName"/> is unknown.</exception>
        </member>
        <member name="T:NHapi.Base.Log.EntLibLogger">
            <summary>
            Logger implementation logging to Enterprise Library Logging Block.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.EntLibLogger.DebugEnabled">
            <summary>
            EntLib does not allow us to check for DebugEnabled, so we return true always.
            This can be filtered out at the configuration level.
            </summary>
        </member>
        <member name="T:NHapi.Base.Log.HapiLogFactory">
            <summary>
            Factory for creating <see cref="T:NHapi.Base.Log.IHapiLog"/> instances. It is a factory
            that delegates the discovery process to the <see cref="T:NHapi.Base.Log.LogFactory"/>
            class and wraps the discovered <see cref="T:NHapi.Base.Log.ILog"/> with a new instance of
            the <see cref="T:NHapi.Base.Log.HapiLogImpl"/> class.
            </summary>
            <author>
            <a href="mailto:alexei.guevara@uhn.on.ca">Alexei Guevara</a>
            </author>
            <version>
            $Revision: 1.2 $ updated on $Date: 2003/05/07 20:12:36 $ by $Author: aguevara $.
            </version>
        </member>
        <member name="M:NHapi.Base.Log.HapiLogFactory.#ctor">
            <summary> Do not allow instantiation.</summary>
        </member>
        <member name="M:NHapi.Base.Log.HapiLogFactory.GetHapiLog(System.Type)">
            <summary>
            Convenience method to return a named HAPI logger, without the application
            having to care about factories.
            </summary>
            <param name="clazz">Class for which a log name will be derived.</param>
        </member>
        <member name="M:NHapi.Base.Log.HapiLogFactory.GetHapiLog(System.String)">
            <summary>
            Convenience method to return a named HAPI logger, without the application
            having to care about factories.
            </summary>
            <param name="name">
            Logical name of the <see cref="T:NHapi.Base.Log.ILog"/> instance to be
            returned (the meaning of this name is only known to the underlying
            logging implementation that is being wrapped).
            </param>
        </member>
        <member name="T:NHapi.Base.Log.HapiLogImpl">
             <summary> Provides a base implementation of the. <code>HapiLog</code> interface.
            
             It delegates all method calls declared by. <code>Log</code> to the delegate specified in
             the constructor.
            
             </summary>
             <author>  <a href="mailto:alexei.guevara@uhn.on.ca">Alexei Guevara</a>
             </author>
             <version>  $Revision: 1.2 $ updated on $Date: 2003/05/26 20:17:06 $ by $Author: aguevara $.
             </version>
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.DebugEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.ErrorEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.FatalEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.InfoEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.TraceEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.HapiLogImpl.WarnEnabled">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Debug(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Debug(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Error(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Error(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Fatal(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Fatal(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Info(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Info(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.ToString">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Trace(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Trace(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Warn(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Warn(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.HapiLogImpl.Debug(System.String,System.Object[],System.Exception)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Log.IHapiLog">
             <summary> A logging interface that enhances the. <code> Log </code>
             interface with ancillary method to easy up the log messages generation
             by adding MessageFormat like functionality.
            
             Instantiate using {@link HapiLogFactory#getLog( Class clazz)}
             or {@link HapiLogFactory#getLog( String name)}.
            
             <pre>
             USASE PATTERN:
             (look at the jakarta-commons-logging and log4j documentation first)
            
             ...
             import ca.uhn.log.*;
             ...
             class A {
             private static final HapiLog log = HapiLogFactory.getHapiLog( A.class );
            
             public boolean methodA( Object param1 ) {
             boolean retVal = true;
            
             //log debug messages (to be printed only when the debug mode is specified
             //in the configuration file)
             log.debug( "param1 = " + param1 );
            
             Object copy = null;
             try {
             copy = param1.clone();
             }
             catch( CloneNotSupportedException e ) {
             //log the error
             log.error( "param1 must be cloneable", e );
             retVal = false;
             }
            
             log.debug( "retVal = " + retVal );
             return retVal;
             }
            
             ...
            
             }
             </pre>
            
             </summary>
             <author>  <a href="mailto:alexei.guevara@uhn.on.ca">Alexei Guevara</a>
             </author>
             <version>  $Revision: 1.4 $ updated on $Date: 2003/09/11 21:51:21 $ by $Author: bryan_tripp $.
             </version>
             TODO: HapiLog inherited from base Log interface using Log = org.apache.commons.logging.Log;
        </member>
        <member name="M:NHapi.Base.Log.IHapiLog.Debug(System.String,System.Object[],System.Exception)">
            <summary>
            debug method.
            </summary>
            <param name="msgPattern"></param>
            <param name="values"></param>
            <param name="e"></param>
        </member>
        <member name="T:NHapi.Base.Log.ILog">
             <summary>
            
             </summary>
             <remarks>Added for conversion will need to replace.</remarks>
        </member>
        <member name="P:NHapi.Base.Log.ILog.DebugEnabled">
            <summary>
            Gets a value indicating whether or not debug level logging is enabled.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.ILog.ErrorEnabled">
            <summary>
            Gets a value indicating whether or not error level logging is enabled.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.ILog.FatalEnabled">
            <summary>
            Gets a value indicating whether or not fatal level logging is enabled.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.ILog.InfoEnabled">
            <summary>
            Gets a value indicating whether or not info level logging is enabled.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.ILog.TraceEnabled">
            <summary>
            Gets a value indicating whether or not trace level logging is enabled.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.ILog.WarnEnabled">
            <summary>
            Gets a value indicating whether or not warning level logging is enabled.
            </summary>
        </member>
        <member name="T:NHapi.Base.Log.DummyLogger">
            <summary>
            Dummy logger.
            </summary>
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.DebugEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.ErrorEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.FatalEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.InfoEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.TraceEnabled">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Log.DummyLogger.WarnEnabled">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Debug(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Debug(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Error(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Error(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Fatal(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Fatal(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Info(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Info(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Trace(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Trace(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Warn(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Log.DummyLogger.Warn(System.Object,System.Exception)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Log.LogFactory">
            <summary>
            Placeholder for LogFactory to get project to compile.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.AbstractGroup">
            <summary> A partial implementation of Group.  Subclasses correspond to specific
            groups of segments (and/or other sub-groups) that are implicitly defined by message structures
            in the HL7 specification.  A subclass should define it's group structure by putting repeated calls to
            the add(...) method in it's constructor.  Each call to add(...) adds a specific component to the
            Group.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.#ctor(NHapi.Base.Model.IGroup,NHapi.Base.Parser.IModelClassFactory)">
             <summary> This constructor should be used by implementing classes that do not
             also implement Message.
            
             </summary>
             <param name="parentStructure">the group to which this Group belongs.
             </param>
             <param name="factory">the factory for classes of segments, groups, and datatypes under this group.
             </param>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            This constructor should only be used by classes that implement Message directly.
            </summary>
            <param name="factory">the factory for classes of segments, groups, and datatypes under this group.
            </param>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroup.Names">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroup.Message">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroup.ParentStructure">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetStructure(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetStructure(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.AddStructure(System.String)">
            <summary>
            Adds a new item to the Structure.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">
            Thrown when the named Structure is not part of this group
            or if the structure is not repeatable and an item already exists.
            </exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.RemoveStructure(System.String,NHapi.Base.Model.IStructure)">
            <summary>
            Removes the given structure from the named Structure.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">
            Thrown when the named Structure is not part of this Group.
            </exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.RemoveRepetition(System.String,System.Int32)">
            <summary> Removes the structure at the given index from the named Structure. </summary>
            <exception cref = "T:NHapi.Base.HL7Exception" > Thrown when the named Structure is not part of this Group
            or an index greater than the number of items in the structure is supplied.
            </exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.AddNonstandardSegment(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.AddNonstandardSegment(System.String,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.IsRequired(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.IsRepeating(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.IsChoiceElement(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.IsGroup(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.CurrentReps(System.String)">
            <summary> Returns the number of existing repetitions of the named structure.</summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetAll(System.String)">
            <summary> Returns an array of Structure objects by name.  For example, if the Group contains
            an MSH segment and "MSH" is supplied then this call would return a 1-element array
            containing the MSH segment.  Multiple elements are returned when the segment or
            group repeats.  The array may be empty if no repetitions have been accessed
            yet using the get(...) methods.
            </summary>
            <throws>  HL7Exception if the named Structure is not part of this Group.  </throws>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetClass(System.String)">
            <summary> Returns the Class of the Structure at the given name index.  </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetStructureName">
            <summary> Returns the class name (excluding package). </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.Add(System.Type,System.Boolean,System.Boolean)">
            <summary> Adds a new Structure (group or segment) to this Group.  A place for the
            Structure is added to the group but there are initially zero repetitions.
            This method should be used by the constructors of implementing classes
            to specify which Structures the Group contains - Structures should be
            added in the order in which they appear.
            Note that the class is supplied instead of an instance because we want
            there initially to be zero instances of each structure but we want the
            AbstractGroup code to be able to create instances as necessary to support
            get(...) calls.
            </summary>
            <returns> the actual name used to store this structure (may be appended with
            an integer if there are duplicates in the same Group).
            </returns>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetGroupItem(System.String)">
            <summary>
            Gets a group item by name.
            </summary>
            <param name="name">The name of the group item.</param>
            <returns>Group item if found, null otherwise.</returns>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.Insert(System.Type,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.String)">
            <summary> Inserts the given structure into this group, at the
            indicated index number.  This method is used to support handling
            of unexpected segments (e.g. Z-segments).  In contrast, specification
            of the group's normal children should be done at construction time, using the
            add(...) method.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.NameExists(System.String)">
            <summary> Returns true if the class name is already being used. </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.TryToInstantiateStructure(System.Type,System.String)">
            <summary> Attempts to create an instance of the given class and return
            it as a Structure.
            </summary>
            <param name="c">the Structure implementing class.
            </param>
            <param name="name">an optional name of the structure (used by Generic structures; may be null).
            </param>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroup.GetStructureName(System.Type)">
            <summary>
            returns a name for a class of a Structure in this Message.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Model.AbstractGroupItem">
            <summary>
            Abstract group item.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractGroupItem.#ctor(System.String,System.Boolean,System.Boolean,System.Boolean,System.Type)">
            <summary>
            Constructor.
            </summary>
            <param name="name"></param>
            <param name="required"></param>
            <param name="repeating"></param>
            <param name="choiceElement"></param>
            <param name="classType"></param>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.Name">
            <summary>
            Name of the item.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.ClassType">
            <summary>
            The type of class.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.IsRepeating">
            <summary>
            Is item repeating.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.IsRequired">
            <summary>
            Is item required.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.IsChoiceElement">
            <summary>
            Is item a "choice element".
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.Structures">
            <summary>
            The structures of the group item.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractGroupItem.Item(System.Int32)">
            <summary>
            Structure indexer.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Model.AbstractMessage">
            <summary> A default implementation of Message. </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="M:NHapi.Base.Model.AbstractMessage.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <param name="theFactory">factory for model classes (e.g. group, segment) for this message.
            </param>
        </member>
        <member name="P:NHapi.Base.Model.AbstractMessage.Message">
            <summary> Returns this Message object - this is an implementation of the
            abstract method in AbstractGroup.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractMessage.Version">
            <summary> Returns the version number.  This default implementation inspects
            this.GetClass().getName().  This should be overridden if you are putting
            a custom message definition in your own package, or it will default.
            </summary>
            <returns>s 2.4 if not obvious from package name.
            </returns>
        </member>
        <member name="P:NHapi.Base.Model.AbstractMessage.ValidationContext">
            <summary>
            The validation context.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.AbstractPrimitive">
             <summary> Base class for Primitives.  Performs validation in setValue().
            
             </summary>
             <author>  Bryan Tripp.
             </author>
        </member>
        <member name="M:NHapi.Base.Model.AbstractPrimitive.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            <param name="message">message to which this type belongs
            </param>
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractPrimitive.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            <param name="message">message to which this type belongs
            <param name="description">The description of the primitive</param>
            </param>
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractPrimitive.Value">
            <summary>
            Sets the value of this Primitive, first performing validation as specified
            by. <see cref="P:NHapi.Base.Model.AbstractMessage.ValidationContext">Message.ValidationContext</see>
            No validation is performed if <see cref="P:NHapi.Base.Model.AbstractType.Message"/> returns null.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractPrimitive.ToString">
            <summary> Returns the value of getValue(). </summary>
        </member>
        <member name="T:NHapi.Base.Model.AbstractSegment">
            <summary> Provides common functionality needed by implementers of the Segment interface.
            Implementing classes should define all the fields for the segment they represent
            in their constructor.  The add() method is useful for this purpose.
            For example the constructor for an MSA segment might contain the following code:
            <code>this.add(new ID(), true, 2, null);
            this.add(new ST(), true, 20, null);</code>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net)
            </author>
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.#cctor">
            <summary> Sets the segment name.  This would normally be called by a Parser. </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.#ctor(NHapi.Base.Model.IGroup,NHapi.Base.Parser.IModelClassFactory)">
             <summary> Calls the abstract init() method to create the fields in this segment.
            
             </summary>
             <param name="parentStructure">parent group.
             </param>
             <param name="factory">all implementors need a model class factory to find datatype classes, so we
             include it as an arg here to emphasize that fact ... AbstractSegment doesn't actually
             use it though.
             </param>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegment.Message">
            <summary> Returns the Message to which this segment belongs.  </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegment.ParentStructure">
            <summary>
            Immediate parent Group or message containing this segment.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetField(System.Int32)">
            <summary> Returns an array of Field objects at the specified location in the segment.  In the case of
            non-repeating fields the array will be of length one.  Fields are numbered from 1.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetFieldDescription(System.Int32)">
            <summary> Return the field description.  Fields are numbered from 1.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetTotalFieldRepetitionsUsed(System.Int32)">
            <summary>
            Returns the total number of items used for the field X.  Fields are numbered from 1.
            </summary>
            <param name="number">Field Number (Starts at 1).</param>
            <returns>0 if no fields users, otherwise, the number of fields used.</returns>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetField(System.Int32,System.Int32)">
            <summary> Returns a specific repetition of field at the specified index.  If there exist
            fewer repetitions than are required, the number of repetitions can be increased
            by specifying the lowest repetition that does not yet exist.  For example
            if there are two repetitions but three are needed, the third can be created
            and accessed using the following code:
            <code>Type t = GetField(x, 3);</code>
            <param name="number">the field number</param>
            <param name="rep">the repetition number (starting at 0) </param>
            <throws>  HL7Exception if field index is out of range, if the specified  </throws>
            repetition is greater than the maximum allowed, or if the specified
            repetition is more than 1 greater than the existing # of repetitions.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.IsRequired(System.Int32)">
            <summary> Returns true if the given field is required in this segment - fields are
            numbered from 1.
            </summary>
            <throws>  HL7Exception if field index is out of range.   </throws>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetLength(System.Int32)">
            <summary> Returns the maximum length of the field at the given index, in characters -
            fields are numbered from 1.
            </summary>
            <throws>  HL7Exception if field index is out of range.   </throws>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetMaxCardinality(System.Int32)">
            <summary> Returns the number of repetitions of this field that are allowed.  </summary>
            <throws>  HL7Exception if field index is out of range. </throws>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.RemoveRepetition(System.Int32,System.Int32)">
            <summary>
            Remove a valid index from a repeatable field.
            </summary>
            <param name="fieldNum">Repeatable field number.</param>
            <param name="index">0-based index to be removed.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If field has no repetitions.</exception>
            <exception cref="T:NHapi.Base.HL7Exception">If field index does not exist.</exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.RemoveRepetition(System.Int32,NHapi.Base.Model.IType)">
            <summary>
            Remove a valid item from a repeatable field.
            </summary>
            <param name="fieldNum">Repeatable field number.</param>
            <param name="removeItem">Item to be removed.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If field number is not valid.</exception>
            <exception cref="T:NHapi.Base.HL7Exception">If field has no repetitions.</exception>
            <exception cref="T:NHapi.Base.HL7Exception">If field does not contain the repetition to remove.</exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.FindField(System.String)">
            <summary>
            Get the 0-based index for an AbstractSegmentItem with a description that matches the given name.
            </summary>
            <param name="name">Item name, with all whitespace removed.</param>
            <returns>0-based index, if found.  Otherwise, -1.</returns>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.NumFields">
            <summary> Returns the number of fields defined by this segment (repeating
            fields are not counted multiple times).
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.GetStructureName">
            <summary> Returns the class name (excluding package). </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.Add(System.Type,System.Boolean,System.Int32,System.Int32,System.Object[])">
            <summary> Adds a field to the segment.  The field is initially empty (zero repetitions).
            The field number is sequential depending on previous add() calls.  Implementing
            classes should use the add() method in their constructor in order to define fields
            in their segment.
            </summary>
            <param name="c">the class of the data for this field - this should inherit from Type.
            </param>
            <param name="required">whether a value for this field is required in order for the segment
            to be valid.
            </param>
            <param name="maxReps">the maximum number of repetitions - 0 implies that there is no limit.
            </param>
            <param name="length">the maximum length of each repetition of the field (in characters).
            </param>
            <param name="constructorArgs">an array of objects that will be used as constructor arguments
            if new instances of this class are created (use null for zero-arg constructor).
            </param>
            <throws>  HL7Exception if the given class does not inherit from Type or if it can.  </throws>
            <summary>    not be instantiated.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.Add(System.Type,System.Boolean,System.Int32,System.Int32,System.Object[],System.String)">
            <summary>
            Add a segment.
            </summary>
            <param name="c">The type of segment.</param>
            <param name="required"></param>
            <param name="maxReps"></param>
            <param name="length"></param>
            <param name="constructorArgs"></param>
            <param name="description"></param>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.CreateNewType(System.Int32)">
            <summary> Creates a new instance of the Type at the given field number in this segment.  </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegment.EnsureEnoughFields(System.Int32)">
            <summary> Called from GetField(...) methods.  If a field has been requested that
            doesn't exist (eg GetField(15) when only 10 fields in segment) adds Varies
            fields to the end of the segment up to the required number.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegmentItem.#ctor(System.Type,System.Boolean,System.Int32,System.Int32,System.Object[])">
            <summary>
            Constructor.
            </summary>
            <param name="t">the class of the data for this field - this should inherit from IType.</param>
            <param name="required">whether a value for this field is required in order for the segment to be valid.</param>
            <param name="maxReps">the maximum number of repetitions - 0 implies that there is no limit.</param>
            <param name="length">the maximum length of each repetition of the field (in characters).</param>
            <param name="constructorArgs">
            an array of objects that will be used as constructor arguments
            if new instances of this class are created (use null for zero-arg constructor).
            </param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the given class does not inherit from IType or if it cannot be instantiated.</exception>
        </member>
        <member name="M:NHapi.Base.Model.AbstractSegmentItem.#ctor(System.Type,System.Boolean,System.Int32,System.Int32,System.Object[],System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="t">the class of the data for this field - this should inherit from IType.</param>
            <param name="required">whether a value for this field is required in order for the segment to be valid.</param>
            <param name="maxReps">the maximum number of repetitions - 0 implies that there is no limit.</param>
            <param name="length">the maximum length of each repetition of the field (in characters). </param>
            <param name="constructorArgs">an array of objects that will be used as constructor arguments if new instances of this class are created (use null for zero-arg constructor).</param>
            <param name="description">Description of the segment.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the given class does not inherit from IType or if it cannot be instantiated.</exception>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.FieldType">
            <summary>
            The IType of this field in the segment.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.IsRequired">
            <summary>
            Is this a required field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.Length">
            <summary>
            What is the length in characters of the field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.Args">
            <summary>
            Arguments to pass to a constructor for this field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.MaxRepetitions">
            <summary>
            Maximum number of repetitions of this field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.Description">
            <summary>
            What is this field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.Fields">
             <summary>
            
             </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractSegmentItem.Item(System.Int32)">
            <summary>
            Return a specific repetition of this field.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Model.AbstractType">
             <summary> An abstract Type that provides a default implementation of getName().
            
             </summary>
             <author>  Bryan Tripp.
             </author>
        </member>
        <member name="M:NHapi.Base.Model.AbstractType.#ctor(NHapi.Base.Model.IMessage)">
            <summary> Creates a new instance of AbstractType.</summary>
            <param name="message">message to which this type belongs.
            </param>
        </member>
        <member name="M:NHapi.Base.Model.AbstractType.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary> Creates a new instance of AbstractType.</summary>
            <param name="message">message to which this type belongs.
            <param name="description">The type description</param>
            </param>
        </member>
        <member name="P:NHapi.Base.Model.AbstractType.TypeName">
            <summary>
            Returns the name of the type (used in XML encoding and profile checking).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractType.ExtraComponents">
            <summary>
            Extra components.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.AbstractType.Message">
            <returns> the message to which this Type belongs.
            </returns>
        </member>
        <member name="P:NHapi.Base.Model.AbstractType.Description">
            <summary>
            Return the description of the type.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.DataTypeUtil">
            <summary> This class is used to provide utility functions for other datatype classes and methods.</summary>
        </member>
        <member name="M:NHapi.Base.Model.DataTypeUtil.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.DataTypeUtil.LocalGMTOffset">
            <summary> This method will return a signed four digit integer indicating the local
            GMT offset. This is the HL7 Offset format in integer representation.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.DataTypeUtil.GetGMTOffset(System.TimeZoneInfo,System.DateTime)">
            <summary>
            This method will return a signed four digit integer indicating the
            GMT offset for the given TimeZoneInfo when applied to the given DateTime.
            This is the HL7 Offset format in integer representation.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.DataTypeUtil.PreAppendZeroes(System.Int32,System.Int32)">
            <summary> This method will pre-append the zeros to the beginning of num such that the total length
            equals totalDigitLength. It will also return the string representation of the new number.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.ExtraComponents">
             <summary>
             <para>
             A set of "extra" components (sub-components) that are not a standard part
             of a field (component) but have been added at runtime.  The purpose is to allow
             processing of locally-defined extensions to datatypes without the need for a
             custom message definition.
             </para>
            
             <para>
             Extra components are not treated uniformly with standard components (e.g.
             they are not accessible through methods like Primitive.getValue() and
             Composite.getComponent()).  To do so would blur the distinction between
             primitive and composite types (i.e. leaf and non-leaf nodes), which seems
             nice and polymorphic for a moment but actually isn't helpful.
             Furthermore, the auto-generated classes do not define accessors to extra
             components, because they are meant to encourage and enforce use of the standard
             message structure -- stepping outside the standard structure must be
             deliberate.
             </para>
            
             <para>
             Note that a uniformity of access to standard and extra components is provided
             by Terser.
             </para>
             </summary>
             <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Model.ExtraComponents.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Creates a new instance of ExtraComponents.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.ExtraComponents.NumComponents">
            <summary>
            Returns the number of existing extra components.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.ExtraComponents.GetComponent(System.Int32)">
            <summary>
            Returns the component at the given location, creating it
            and all preceding components if necessary.
            </summary>
            <param name="comp">
            The extra component number starting at 0 (i.e. 0 is the first extra component).
            </param>
        </member>
        <member name="M:NHapi.Base.Model.ExtraComponents.EnsureComponentAndPredecessorsExist(System.Int32)">
            <summary> Checks that the component at the given location exists, and that
            all preceding components exist, creating any missing ones.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericComposite">
            <summary>
            An unspecified Composite datatype that has an undefined number of components, each
            of which is a Varies.
            This is used to store Varies data, when the data type is unknown.  It is also
            used to store unrecognized message constituents.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Model.GenericComposite.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Creates a new instance of GenericComposite.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
        </member>
        <member name="M:NHapi.Base.Model.GenericComposite.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Creates a new instance of GenericComposite.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="description">The description of this type.</param>
        </member>
        <member name="P:NHapi.Base.Model.GenericComposite.Components">
            <summary>
            Returns an array containing the components of this field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.GenericComposite.TypeName">
            <summary>
            Returns the name of the type (used in XML encoding and profile checking).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.GenericComposite.Item(System.Int32)">
            <summary>
            Returns the single component of this composite at the specified position (starting at 0) -
            Creates it (and any nonexistent components before it) if necessary.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericGroup">
            <summary>
            An undefined segment group. This is for storing undefined groups
            that appear in XML-encoded messages. Note that if an undefined group appears
            in an ER7-encoded message, the group structure won't be clear and we'll just assume
            it's a flat list of segments.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Model.GenericGroup.#ctor(NHapi.Base.Model.IGroup,System.String,NHapi.Base.Parser.IModelClassFactory)">
            <summary>Creates a new instance of GenericGroup. </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericGroup.GetStructureName">
            <summary>
            Returns the name specified at construction time.
            </summary>
            <seealso cref="M:NHapi.Base.Model.IStructure.GetStructureName"></seealso>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage">
            <summary>
            A generic HL7 message, meant for parsing message with unrecognized structures
            into a flat list of segments.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Creates a new instance of GenericMessage.
            </summary>
            <param name="factory">class factory for contained structures.</param>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.GetGenericMessageClass(System.String)">
            <summary>
            Returns a subclass of GenericMessage corresponding to a certain version.
            This is needed so that version-specific segments can be added as the message
            is parsed.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V21">
            <summary>
            Version 2.1 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V21.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V21.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V22">
            <summary>
            Version 2.2 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V22.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V22.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V23">
            <summary>
            Version 2.3 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V23.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V23.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V231">
            <summary>
            Version 2.3.1 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V231.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V231.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V24">
            <summary>
            Version 2.4 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V24.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V24.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V25">
            <summary>
            Version 2.5 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V25.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V25.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V251">
            <summary>
            Version 2.5.1 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V251.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V251.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V26">
            <summary>
            Version 2.6 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V26.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V26.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V27">
            <summary>
            Version 2.7 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V27.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V27.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V271">
            <summary>
            Version 2.7.1 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V271.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V271.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V28">
            <summary>
            Version 2.8 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V28.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V28.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericMessage.V281">
            <summary>
            Version 2.8.1 generic message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericMessage.V281.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Constructor.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="P:NHapi.Base.Model.GenericMessage.V281.Version">
            <summary>
            Version of message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericPrimitive">
            <summary>
            An unspecified Primitive datatype that imposes no constraints on its string
            value. This is used to store Varies data, when the data type is unknown. It is also
            used to store unrecognized message constituents.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Model.GenericPrimitive.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Creates a new instance of GenericPrimitive.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.GenericPrimitive.Value">
            <summary>
            Gets or sets the string representation of the value of this field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.GenericPrimitive.TypeName">
            <summary>
            Returns the name of the type (used in XML encoding and profile checking).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.GenericPrimitive.Version">
            <summary>
            Gets the version.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.GenericSegment">
            <summary> An unspecified segment that has an undefined number of fields, each
            of which is a Varies.  The primary intended use is to store data from
            Z segments.  More precisely, any unknown segment that is encountered during
            parsing will be handled with this class.  This includes segments that do
            not start with Z but nevertheless do not appear in the stated version
            of HL7.  Also, this class is not used to handle Z segments that have been
            explicitly defined and declared (see Parser.PackageList() ).
            </summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="M:NHapi.Base.Model.GenericSegment.#ctor(NHapi.Base.Model.IGroup,System.String)">
            <summary>Creates a new instance of GenericSegment. </summary>
        </member>
        <member name="M:NHapi.Base.Model.GenericSegment.GetStructureName">
            <summary> Returns the name specified at construction time. </summary>
            <seealso cref="M:NHapi.Base.Model.IStructure.GetStructureName" />
        </member>
        <member name="T:NHapi.Base.Model.IComposite">
            <summary> <p>Represents the category of HL7 data types that contain more than one component (e.g. CE).
            Implementing classes (i.e. composite data types) should initialize their components
            either when they are initialized or when they are first accessed.  Only leaf values
            (values of primitives) should ever be returned as null.</p>
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IComposite.Components">
            <summary> Returns an array containing the components of this field.</summary>
        </member>
        <member name="T:NHapi.Base.Model.IGroup">
            <summary> An abstraction representing >1 message parts which may repeated together.
            An implementation of Group should enforce constraints about on the contents of the group
            and throw an exception if an attempt is made to add a Structure that the Group instance
            does not recognize.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IGroup.Names">
            <summary>
            Returns an ordered array of the names of the Structures in this Group.
            <para>
            These names can be used to iterate through the group using repeated
            calls to <see cref="M:NHapi.Base.Model.IGroup.GetStructure(System.String)"/>.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.GetAll(System.String)">
            <summary> Returns an array of Structure objects by name.  For example, if the Group contains
            an MSH segment and "MSH" is supplied then this call would return a 1-element array
            containing the MSH segment.  Multiple elements are returned when the segment or
            group repeats.  The array may be empty if no repetitions have been accessed
            yet using the GetStructure(...) methods.
            </summary>
            <param name="name">Name of the structure.</param>
            <returns>Array of Structure objects.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the named Structure is not part of this Group.</exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.GetStructure(System.String)">
            <summary> Returns the named structure.  If this Structure is repeating then the first
            repetition is returned.  Creates the Structure if necessary.
            </summary>
            <param name="name">Name of the structure.</param>
            <returns>First (or only) structure object.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the named Structure is not part of this Group.</exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.GetStructure(System.String,System.Int32)">
            <summary> Returns a particular repetition of the named Structure. If the given repetition
            number is one greater than the existing number of repetitions then a new
            Structure is created.
            </summary>
            <param name="name">Name of the structure.</param>
            <param name="rep">Repetition (zero-based).</param>
            <returns>particular repetition of the named structure.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">if the named Structure is not part of this Group,
            if the structure is not repeatable and the given rep is > 0,
            or if the given repetition number is more than one greater than the
            existing number of repetitions.
            </exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.IsRequired(System.String)">
            <summary> Returns true if the named structure is required. </summary>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.IsRepeating(System.String)">
            <summary> Returns true if the named structure is repeating. </summary>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.IsChoiceElement(System.String)">
            <summary>
            Returns true if the named structure is a "choice element".
            Some HL7 structures(e.g.ORM_O01 in v2.5) have groups that have
            several possible first segments.In these structures, one of these
            "choice elements" must be present, but not more than one.
            </summary>
            <param name="name">name of the structure nested in this group.</param>
            <returns>true if structure is a choice element.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">if the named Structure is not part of this group.</exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.IsGroup(System.String)">
            <summary>
            Returns true if the named structure is a group.
            </summary>
            <param name="name">name of the structure nested in this group.</param>
            <returns>true if structure is a choice element.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">if the named Structure is not part of this group.</exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.GetClass(System.String)">
            <summary> Returns the Class of the Structure at the given name index.  </summary>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.AddNonstandardSegment(System.String)">
            <summary> Expands the group definition to include a segment that is not
            defined by HL7 to be part of this group (eg an unregistered Z segment).
            The new segment is slotted at the end of the group.  Thenceforward if
            such a segment is encountered it will be parsed into this location.
            If the segment name is unrecognized a GenericSegment is used.  The
            segment is defined as repeating and not required.
            </summary>
            <param name="name">name of the segment.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown when <see cref="P:NHapi.Base.Model.IMessage.Version"/> returns null.</exception>
        </member>
        <member name="M:NHapi.Base.Model.IGroup.AddNonstandardSegment(System.String,System.Int32)">
            <summary> Expands the group definition to include a segment that is not
            defined by HL7 to be part of this group (eg an unregistered Z segment).
            The new segment is slotted at the end of the group.  Thenceforward if
            such a segment is encountered it will be parsed into this location.
            If the segment name is unrecognized a GenericSegment is used.  The
            segment is defined as repeating and not required.
            </summary>
            <param name="name">name of the segment.</param>
            <param name="index">index (zero-based) at which to insert this segment.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown when <see cref="P:NHapi.Base.Model.IMessage.Version"/> returns null.</exception>
        </member>
        <member name="T:NHapi.Base.Model.IMessage">
            <summary> Represents a complete HL7 message including all structures, segments, and fields.  </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IMessage.Version">
            <summary> Returns the version number of the HL7 version in which this
            message structure is defined (e.g. "2.4").
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.IMessage.ValidationContext">
            <summary>
            The validation context of the message.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.IPrimitive">
            <summary> Represents the category of HL7 data types that contain a single value (in other
            words have no subcomponents).  Examples include ST and ID.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IPrimitive.Value">
            <summary> Returns a String representation of the value of this field.</summary>
            <summary> Sets the value of this field if the given value is legal in the context of the
            implementing class.
            </summary>
            <throws>  DataTypeException if the given value is not valid in this context. </throws>
        </member>
        <member name="T:NHapi.Base.Model.ISegment">
            <summary>
            Represents an HL7 message segment, which is a unit of data that contains multiple fields.
            </summary>
            <author>Bryan Tripp (bryan_tripp@sourceforge.net).</author>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.GetField(System.Int32)">
            <summary>
            Returns the array of Fields at the specified index.  The array will be of length 1 for
            non-repeating fields, and >1 for repeating fields.  Fields are numbered from 1.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown when field index is out of range.</exception>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.GetField(System.Int32,System.Int32)">
            <summary>
            <para>
            Returns a specific repetition of field at the specified index.  If there exist
            fewer repetitions than are required, the number of repetitions can be increased
            by specifying the lowest repetition that does not yet exist.  For example
            if there are two repetitions but three are needed, the third can be created
            and accessed using the following code: <br />
            <code>Type t = GetField(x, 2);</code>
            </para>
            <para>
            NOTE: to facilitate local extensions, no exception is thrown if
            rep > max cardinality.
            </para>
            </summary>
            <param name="number">the field number.</param>
            <param name="rep">the repetition number (starting at 0).</param>
            <throws>  HL7Exception if field index is out of range, or if the specified.   </throws>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.IsRequired(System.Int32)">
            <summary> Returns true if the field at the given index is required, false otherwise.</summary>
            <throws>  HL7Exception if field index is out of range. </throws>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.GetLength(System.Int32)">
            <summary> Returns the maximum length of the field at the given index, in characters.</summary>
            <throws>  HL7Exception if field index is out of range. </throws>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.GetMaxCardinality(System.Int32)">
            <summary> Returns the maximum number of repetitions of this field that are allowed.
            The current cardinality can be obtained by checking the length
            of the array returned by GetLength(n).
            </summary>
            <throws>  HL7Exception if field index is out of range. </throws>
        </member>
        <member name="M:NHapi.Base.Model.ISegment.NumFields">
            <summary> Returns the number of fields defined by this segment (repeating
            fields are not counted multiple times).
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.IStructure">
            <summary> Part of an HL7 message: either a segment or group.  There are certain methods (e.g. Group.get())
            that will always return either a segment or a group.  This interface allows methods like this
            to declare a return type of Structure instead of Object.
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IStructure.Message">
            <summary>
            Returns the Message object to which this structure belongs.
            <para>
            This should normally be set at construction time.
            </para>
            <para>
            A Structure can only belong to a single Message.
            This is primarily to avoid a situation where intended changes in one message cause unintended changes
            in another that shares one of the same Structure objects.
            </para>
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.IStructure.ParentStructure">
            <summary>
            Returns the parent group within which this structure exists (may be root
            message group).
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.IStructure.GetStructureName">
            <summary>
            Returns the structure's name.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.IType">
            <summary> An HL7 datatype.  Datatypes normally implement either Composite or Primitive.    </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="P:NHapi.Base.Model.IType.TypeName">
            <summary>Returns the name of the type (used in XML encoding and profile checking). </summary>
        </member>
        <member name="P:NHapi.Base.Model.IType.ExtraComponents">
            <summary> Returns an object containing any extra (non-standard) components that
            have been added to this type at run-time.  This object can also be used
            to add components.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.IType.Message">
            <returns> the message to which this Type belongs.
            </returns>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.CommonDT">
             <summary>
             This class contains functionality used by the DT class
             in the version 2.3.0, 2.3.1, and 2.4 packages
            
             Note: The class description below has been excerpted from the Hl7 2.4 documentation. Sectional
             references made below also refer to the same documentation.
            
             Format: YYYY[MM[DD]]
             In prior versions of HL7, this data type was always specified to be in the format YYYYMMDD. In the current and future
             versions, the precision of a date may be expressed by limiting the number of digits used with the format specification
             YYYY[MM[DD]]. Thus, YYYY is used to specify a precision of "year," YYYYMM specifies a precision of "month,"
             and YYYYMMDD specifies a precision of "day."
             By site-specific agreement, YYYYMMDD may be used where backward compatibility must be maintained.
             Examples:   |19880704|  |199503|.
             </summary>
             <author>Neal Acharya.</author>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonDT.#ctor">
            <summary>
            Constructs a DT datatype with fields initialized to zero and value initialized to null.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonDT.#ctor(System.String)">
            <summary>
            Constructs a DT object with the given value.
            The stored value will be in the following
            format YYYY[MM[DD]].
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonDT.Value">
            <summary>
            Gets or sets the HL7 DT string value.
            </summary>
            <remarks>
            This method takes in a string HL7 date value and performs validations
            then sets the value field. The stored value will be in the following
            format YYYY[MM[DD]].
            </remarks>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonDT.YearPrecision">
            <summary>
            This method takes in an integer value for the year and performs validations,
            it then sets the value field formatted as an HL7 date.
            value with year precision (YYYY).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonDT.Year">
            <summary> Returns the year as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonDT.Month">
            <summary> Returns the month as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonDT.Day">
            <summary> Returns the day as an integer.</summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonDT.ToHl7DTFormat(System.Globalization.GregorianCalendar)">
            <summary> Returns a string value representing the input Gregorian Calendar object in
            an Hl7 Date Format.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonDT.SetYearMonthPrecision(System.Int32,System.Int32)">
            <summary> This method takes in integer values for the year and month and performs validations,
            it then sets the value field formatted as an HL7 date
            value with year and month precision (YYYYMM).
            Note: The first month = 1 = January.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonDT.SetYearMonthDayPrecision(System.Int32,System.Int32,System.Int32)">
            <summary> This method takes in integer values for the year and month and day
            and performs validations, it then sets the value in the object
            formatted as an HL7 date value with year and month and day precision (YYYYMMDD).
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.CommonTM">
             <summary>
             This class contains functionality used by the TM class
             in the version 2.3.0, 2.3.1, and 2.4 packages
            
             Note: The class description below has been excerpted from the Hl7 2.4 documentation. Sectional
             references made below also refer to the same documentation.
            
             Format: HH[MM[SS[.S[S[S[S]]]]]][+/-ZZZZ]
             In prior versions of HL7, this data type was always specified to be in the
             format HHMM[SS[.SSSS]][+/-ZZZZ] using a 24 hour clock notation. In the
             current and future versions, the precision of a time may be expressed by
             limiting the number of digits used with the format specification as shown
             above. By site-specific agreement, HHMM[SS[.SSSS]][+/-ZZZZ] may be used where
             backward compatibility must be maintained.
             Thus, HH is used to specify a precision of "hour," HHMM is used to specify a
             precision of "minute," HHMMSS is used to specify a precision of seconds, and
             HHMMSS.SSSS is used to specify a precision of ten-thousandths of a second.
             In each of these cases, the time zone is an optional component. The fractional
             seconds could be sent by a transmitter who requires greater precision than whole
             seconds. Fractional representations of minutes, hours or other higher-order units
             of time are not permitted.
             Note: The time zone [+/-ZZZZ], when used, is restricted to legally-defined time zones
             and is represented in HHMM format.
             The time zone of the sender may be sent optionally as an offset from the coordinated
             universal time (previously known as Greenwich Mean Time). Where the time zone
             is not present in a particular TM field but is included as part of the date/time
             field in the MSH segment, the MSH value will be used as the default time zone.
             Otherwise, the time is understood to refer to the local time of the sender.
             Midnight is represented as 0000.
             Examples:|235959+1100| 1 second before midnight in a time zone eleven hours
             ahead of Universal Coordinated Time (i.e., east of Greenwich).
             |0800| Eight AM, local time of the sender.
             |093544.2312| 44.2312 seconds after Nine thirty-five AM, local time of sender.
             |13| 1pm (with a precision of hours), local time of sender.
             </summary>
             <author>Neal Acharya.</author>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTM.#ctor">
            <summary>
            Constructs a TM datatype with fields initialized to zero and the value set to null.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTM.#ctor(System.String)">
            <summary>
            Constructs a TM object with the given value.
            The stored value will be in the following
            format HH[MM[SS[.S[S[S[S]]]]]][+/-ZZZZ].
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.Value">
            <summary> Returns the HL7 TM string value.</summary>
            <summary> This method takes in a string HL7 Time value and performs validations
            then sets the value field.  The stored value will be in the following
            format HH[MM[SS[.S[S[S[S]]]]]][+/-ZZZZ].
            Note: Trailing zeros supplied in the time value (HH[MM[SS[.S[S[S[S]]]]]])
            and GMT offset ([+/-ZZZZ]) will be preserved.
            Note: If the GMT offset is not supplied then the local
            time zone (using standard time zone format which is not modified for daylight savings)
            will be stored as a default.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.HourPrecision">
            <summary>
            This method takes in an integer value for the hour and performs validations,
            it then sets the value field formatted as an HL7 time
            value with hour precision (HH).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.Offset">
            <summary>
            This method takes in the four digit (signed) GMT offset and sets the offset field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.Hour">
            <summary>
            Returns the hour as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.Minute">
            <summary>
            Returns the minute as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.Second">
            <summary>
            Returns the second as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.FractSecond">
            <summary>
            Returns the fractional second value as a float.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTM.GMTOffset">
            <summary>
            Returns the GMT offset value as an integer, -99 if not set.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTM.ToHl7TMFormat(System.Globalization.GregorianCalendar)">
            <summary>
            Returns a string value representing the input Gregorian Calendar object in
            an Hl7 Time Format.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTM.SetHourMinutePrecision(System.Int32,System.Int32)">
            <summary>
            This method takes in integer values for the hour and minute and performs validations,
            it then sets the value field formatted as an HL7 time value
            with hour and minute precision (HHMM).
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTM.SetHourMinSecondPrecision(System.Int32,System.Int32,System.Single)">
            <summary>
            This method takes in integer values for the hour, minute, seconds, and fractional seconds
            (going to the ten thousandths precision).
            The method performs validations and then sets the value field formatted as an
            HL7 time value with a precision that starts from the hour and goes down to the ten thousandths
            of a second (HHMMSS.SSSS).
            Note: all of the precisions from tenths down to ten thousandths of a
            second are optional. If the precision goes below ten thousandths of a second then the second
            value will be rounded to the nearest ten thousandths of a second.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.CommonTS">
             <summary>
             This class contains functionality used by the TS class
             in the version 2.3.0, 2.3.1, and 2.4 packages
            
             Note: The class description below has been excerpted from the Hl7 2.4 documentation. Sectional
             references made below also refer to the same documentation.
            
             Format: YYYY[MM[DD[HHMM[SS[.S[S[S[S]]]]]]]][+/-ZZZZ]^[Degree of precision]
             Contains the exact time of an event, including the date and time. The date portion of a time stamp follows the rules of a
             date field and the time portion follows the rules of a time field. The time zone (+/-ZZZZ) is represented as +/-HHMM
             offset from UTC (formerly Greenwich Mean Time (GMT)), where +0000 or -0000 both represent UTC (without offset).
             The specific data representations used in the HL7 encoding rules are compatible with ISO 8824-1987(E).
             In prior versions of HL7, an optional second component indicates the degree of precision of the time stamp (Y = year, L
             = month, D = day, H = hour, M = minute, S = second). This optional second component is retained only for purposes of
             backward compatibility.
             By site-specific agreement, YYYYMMDD[HHMM[SS[.S[S[S[S]]]]]][+/-ZZZZ]^[degree of precision] may be used
             where backward compatibility must be maintained.
             In the current and future versions of HL7, the precision is indicated by limiting the number of digits used, unless the
             optional second component is present. Thus, YYYY is used to specify a precision of "year," YYYYMM specifies a
             precision of "month," YYYYMMDD specifies a precision of "day," YYYYMMDDHH is used to specify a precision of
             "hour," YYYYMMDDHHMM is used to specify a precision of "minute," YYYYMMDDHHMMSS is used to specify a
             precision of seconds, and YYYYMMDDHHMMSS.SSSS is used to specify a precision of ten thousandths of a second.
             In each of these cases, the time zone is an optional component. Note that if the time zone is not included, the timezone
             defaults to that of the local time zone of the sender. Also note that a TS valued field with the HHMM part set to "0000"
             represents midnight of the night extending from the previous day to the day given by the YYYYMMDD part (see example
             below). Maximum length of the time stamp is 26. Examples:
             |19760704010159-0500|
             1:01:59 on July 4, 1976 in the Eastern Standard Time zone (USA).
             |19760704010159-0400|
             1:01:59 on July 4, 1976 in the Eastern Daylight Saving Time zone (USA).
             |198807050000|
             Midnight of the night extending from July 4 to July 5, 1988 in the local time zone of the sender.
             |19880705|
             Same as prior example, but precision extends only to the day. Could be used for a birth date, if the time of birth is
             unknown.
             |19981004010159+0100|
             1:01:59 on October 4, 1998 in Amsterdam, NL. (Time zone=+0100).
             The HL7 Standard strongly recommends that all systems routinely send the time zone offset but does not require it. All
             HL7 systems are required to accept the time zone offset, but its implementation is application specific. For many
             applications the time of interest is the local time of the sender. For example, an application in the Eastern Standard Time
             zone receiving notification of an admission that takes place at 11:00 PM in San Francisco on December 11 would prefer
             to treat the admission as having occurred on December 11 rather than advancing the date to December 12.
             Note: The time zone [+/-ZZZZ], when used, is restricted to legally-defined time zones and is represented in HHMM
             format.
             One exception to this rule would be a clinical system that processed patient data collected in a clinic and a nearby hospital
             that happens to be in a different time zone. Such applications may choose to convert the data to a common
             representation. Similar concerns apply to the transitions to and from daylight saving time. HL7 supports such requirements
             by requiring that the time zone information be present when the information is sent. It does not, however, specify which of
             the treatments discussed here will be applied by the receiving system.
             </summary>
             <author>  Neal Acharya.
             </author>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.#ctor">
            <summary>Creates new ValidTS
            zero argument constructor.
            Creates an uninitialized TS datatype.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.#ctor(System.String)">
            <summary> Constructs a TS object with the given value.
            The stored value will be in the following
            format YYYY[MM[DD[HHMM[SS[.S[S[S[S]]]]]]]][+/-ZZZZ].
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Value">
            <summary> Returns the HL7 TS string value.</summary>
            <summary> This method takes in a string HL7 Time Stamp value and performs validations.
            The stored value will be in the following
            format YYYY[MM[DD[HHMM[SS[.S[S[S[S]]]]]]]][+/-ZZZZ].
            Note: Trailing zeros supplied in the time value (HHMM[SS[.S[S[S[S]]]]]])
            and GMT offset ([+/-ZZZZ]) will be preserved.
            Note: If the GMT offset is not supplied then the local
            time zone (using standard time zone format which is not modified for daylight savings)
            will be stored as a default.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Offset">
            <summary> This method takes in the four digit (signed) GMT offset and sets the offset
            field.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Year">
            <summary> Returns the year as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Month">
            <summary> Returns the month as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Day">
            <summary> Returns the day as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Hour">
            <summary> Returns the hour as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Minute">
            <summary> Returns the minute as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.Second">
            <summary> Returns the second as an integer.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.FractSecond">
            <summary> Returns the fractional second value as a float.</summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.CommonTS.GMTOffset">
            <summary> Returns the GMT offset value as an integer.</summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.ToHl7TSFormat(System.Globalization.GregorianCalendar)">
            <summary> Returns a string value representing the input Gregorian Calendar object in
            an Hl7 TimeStamp Format.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.SetDatePrecision(System.Int32,System.Int32,System.Int32)">
             <summary> This method takes in integer values for the year and month and day
             and performs validations, it then sets the value in the object
             formatted as an HL7 Time Stamp value with year and month and day precision (YYYYMMDD).
            
             </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.SetDateMinutePrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> This method takes in integer values for the year, month, day, hour
            and minute and performs validations, it then sets the value in the object
            formatted as an HL7 Time Stamp value with year and month and day and hour and minute precision (YYYYMMDDHHMM).
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.CommonTS.SetDateSecondPrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary> This method takes in integer values for the year, month, day, hour, minute, seconds,
            and fractional seconds (going to the ten thousandths precision).
            The method performs validations and then sets the value in the object formatted as an
            HL7 time value with a precision that starts from the year and goes down to the ten thousandths
            of a second (YYYYMMDDHHMMSS.SSSS).
            The GMT Offset will not be effected.
            Note: all of the precisions from tenths down to
            ten thousandths of a second are optional. If the precision goes below ten thousandths
            of a second then the second value will be rounded to the nearest ten thousandths of a second.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.DT">
            <summary>
            Represents an HL7 DT (date) datatype.
            </summary>
            <author><a href="mailto:neal.acharya@uhn.on.ca">Neal Acharya</a></author>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.3 $ updated on $Date: 2005/06/08 00:28:25 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.DT.#ctor(NHapi.Base.Model.IMessage)">
            <summary>Construct the type.</summary>
            <param name="theMessage">message to which this Type belongs.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.DT.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>Construct the type.</summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="description">The description of this type.</param>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.DT.Value">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Model.Primitive.DT.Year">
            <summary>
            Gets the year as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.DT.Month">
            <summary>
            Gets the month as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.DT.Day">
            <summary>
            Gets the day as an integer.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.DT.SetYearMonthPrecision(System.Int32,System.Int32)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonDT.setYearMonthPrecision(System.Int32,System.Int32)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.DT.SetYearMonthDayPrecision(System.Int32,System.Int32,System.Int32)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonDT.setYearMonthDayPrecision(System.Int32,System.Int32,System.Int32)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.ID">
             <summary>
             <para>
             This class contains functionality used by the ID class
             in the version 2.3.0, 2.3.1, 2.4, and 2.5 packages.
             </para>
            
             <para>
             Note: The class description below has been excerpted from the Hl7 2.4 documentation. Sectional
             references made below also refer to the same documentation.
             </para>
            
             <para>
             The value of such a field follows the formatting rules for an ST field except
             that it is drawn from a table of legal values. There shall be an HL7 table number
             associated with ID data types. An example of an ID field is OBR-25-result status.
             This data type should be used only for HL7 tables (see Section 2.7.6, "Table").
             The reverse is not true, since in some circumstances it is more appropriate to use
             the CE data type for HL7 tables.
             </para>
             </summary>
             <author><a href="mailto:neal.acharya@uhn.on.ca">Neal Acharya</a></author>
             <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
             <version>
             $Revision: 1.3 $ updated on $Date: 2005/06/08 00:28:25 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.ID.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.ID"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.ID.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.ID"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="description">The description of this type.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.ID.#ctor(NHapi.Base.Model.IMessage,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.ID"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="theTable">HL7 table from which values are to be drawn.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.ID.#ctor(NHapi.Base.Model.IMessage,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.ID"/> class.
            </summary>
            <param name="message">message to which this Type belongs.</param>
            <param name="theTable">HL7 table from which values are to be drawn.</param>
            <param name="description"></param>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.ID.Table">
            <summary>
            Gets or sets the number of the HL7 table from which values should be drawn (defaults to 0).
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.IS">
             <summary>
             <para>
             This class contains functionality used by the IS class
             in the version 2.3.0, 2.3.1, 2.4, and 2.5 packages.
             </para>
            
             <para>
             Note: The class description below has been excerpted from the Hl7 2.4 documentation. Sectional
             references made below also refer to the same documentation.
             </para>
            
             <para>
             The value of such a field follows the formatting rules for a ST field except that it is
             drawn from a site-defined (or user-defined) table of legal values. There shall be an HL7
             table number associated with IS data types. An example of an IS field is the Event reason
             code defined in Section 3.3.1.4, "Event reason code." This data type should be used only for
             user-defined tables (see Section 2.7.6, "Table"). The reverse is not true, since in some
             circumstances, it is more appropriate to use the CE data type for user-defined tables.
             </para>
             </summary>
             <author><a href="mailto:neal.acharya@uhn.on.ca">Neal Acharya</a></author>
             <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
             <version>
             $Revision: 1.3 $ updated on $Date: 2005/06/08 00:28:25 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.IS.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.IS"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.IS.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.IS"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="description">The description of this type.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.IS.#ctor(NHapi.Base.Model.IMessage,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.IS"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="theTable">HL7 table from which values are to be drawn.</param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.IS.#ctor(NHapi.Base.Model.IMessage,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHapi.Base.Model.Primitive.IS"/> class.
            </summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="theTable">HL7 table from which values are to be drawn.</param>
            <param name="description"></param>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.IS.Table">
            <summary>
            Gets or sets the number of the HL7 table from which values should be drawn (defaults to 0).
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.TM">
            <summary>
            Represents an HL7 TM (time) datatype.
            </summary>
            <author><a href="mailto:neal.acharya@uhn.on.ca">Neal Acharya</a></author>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.3 $ updated on $Date: 2005/06/08 00:28:25 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TM.#ctor(NHapi.Base.Model.IMessage)">
            <param name="theMessage">message to which this Type belongs.
            </param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TM.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>Construct the type.</summary>
            <param name="theMessage">message to which this Type belongs.</param>
            <param name="description">The description of this type.</param>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.Value">
            <inheritdoc />
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.HourPrecision">
            <summary>
            <seealso cref="P:NHapi.Base.Model.Primitive.CommonTM.HourPrecision" />
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.Offset">
            <summary>
            <seealso cref="P:NHapi.Base.Model.Primitive.CommonTM.Offset" />
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.Hour">
            <summary>
            Returns the hour as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.Minute">
            <summary>
            Returns the minute as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.Second">
            <summary>
            Returns the second as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.FractSecond">
            <summary>
            Returns the fractional second value as a float.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TM.GMTOffset">
            <summary>
            Returns the GMT offset value as an integer.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TM.SetHourMinutePrecision(System.Int32,System.Int32)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonTM.setHourMinutePrecision(System.Int32,System.Int32)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TM.SetHourMinSecondPrecision(System.Int32,System.Int32,System.Single)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonTM.setHourMinSecondPrecision(System.Int32,System.Int32,System.Single)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="T:NHapi.Base.Model.Primitive.TSComponentOne">
             <summary>
             <para>
             Represents an HL7 timestamp, which is related to the HL7 TS type.
             </para>
            
             <para>
             In version 2.5, TS is a composite type. The first component is type DTM, which corresponds to this class
             (actually Model.v25.datatype.DTM inherits from this class at time of writing).
             </para>
            
             <para>
             In HL7 versions 2.2-2.4, it wasn't perfectly clear whether TS was composite or primitive. HAPI interprets
             it as composite, with the first component having a type that isn't defined by HL7, and we call
             this type TSComponentOne.
             </para>
            
             <para>
             In v2.1, TS is primitive, and corresponds one-to-one with this class.
             </para>
             </summary>
             <author><a href="mailto:neal.acharya@uhn.on.ca">Neal Acharya</a></author>
             <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
             <version>
             $Revision: 1.4 $ updated on $Date: 2005/06/14 20:09:39 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.#ctor(NHapi.Base.Model.IMessage)">
            <param name="theMessage">message to which this Type belongs.
            </param>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Offset">
            <summary>
            <seealso cref="P:NHapi.Base.Model.Primitive.CommonTS.Offset" />
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Year">
            <summary>
            Returns the year as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Month">
            <summary>
            Returns the month as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Day">
            <summary>
            Returns the day as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Hour">
            <summary>
            Returns the hour as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Minute">
            <summary>
            Returns the minute as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.Second">
            <summary>
            Returns the second as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.FractSecond">
            <summary>
            Returns the fractional second value as a float.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.GMTOffset">
            <summary>
            Returns the GMT offset value as an integer.
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.LongDateTimeFormat">
            <summary>
            Used for setting the format of a long date (Year, Month, Day, Hour, Minute).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.LongDateTimeFormatWithSecond">
            <summary>
            Used for setting the format of a long date (Year, Month, Day, Hour, Minute, Second).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.LongDateTimeFormatWithOffset">
            <summary>
            Used for setting the format of a long date (Year, Month, Day, Hour, Minute, Second, Offset from GMT).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.LongDateTimeFormatWithFractionOfSecond">
            <summary>
            Used for setting the format of a long date (Year, Month, Day, Hour, Minute, Second, Fraction of second).
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Primitive.TSComponentOne.ShortDateTimeFormat">
            <summary>
            Used for setting the format of a short date (Year, Month, Day).
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetDatePrecision(System.Int32,System.Int32,System.Int32)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonTS.setDatePrecision(System.Int32,System.Int32,System.Int32)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetDateMinutePrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonTS.setDateMinutePrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetDateSecondPrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <seealso cref="M:NHapi.Base.Model.Primitive.CommonTS.setDateSecondPrecision(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            </seealso>
            <throws>  DataTypeException if the value is incorrectly formatted.  If validation is enabled, this.  </throws>
            <summary>      exception should be thrown at setValue(), but if not, detailed parsing may be deferred until
            this method is called.
            </summary>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.GetAsDate">
            <summary>
            Get the value as a date.  Throws hl7Exception if error.
            </summary>
            <returns>Data/Time.</returns>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetShortDate(System.DateTime)">
            <summary>
            Set the value as a short date.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetLongDate(System.DateTime)">
            <summary>
            Set the value as a long date.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetLongDateWithSecond(System.DateTime)">
            <summary>
            Set the value as a long date with second.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.SetLongDateWithFractionOfSecond(System.DateTime)">
            <summary>
            Set the value as a long date with fraction of second.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHapi.Base.Model.Primitive.TSComponentOne.Set(System.DateTime,System.String)">
            <summary>
            Sets the value (to the format specified) using a date.
            </summary>
            <param name="value">Valid date/time.</param>
            <param name="format">The format to set the value (yyyyMMdd, etc).</param>
        </member>
        <member name="T:NHapi.Base.Model.Varies">
            <summary>
            Varies is a Type used as a placeholder for another Type in cases where
            the appropriate Type is not known until run-time (e.g. OBX-5).
            Parsers and validators may have logic that enforces restrictions on the
            Type based on other features of a segment.
            <para>
            If you want to set both the type and the values of a Varies object, you should
            set the type first by calling setData(Type t), keeping a reference to your Type,
            and then set values by calling methods on the Type.
            </para>
            </summary>
            <example>
            <code>
            CN cn = new CN();
            variesObject.Data = cn;
            cn.IDNumber.Value = "foo";
            </code>
            </example>
            <author>Bryan Tripp (bryan_tripp@users.sourceforge.net).</author>
        </member>
        <member name="M:NHapi.Base.Model.Varies.#ctor(NHapi.Base.Model.IMessage)">
            <summary>
            Creates new Varies.
            </summary>
            <param name="message">message to which this type belongs.
            </param>
        </member>
        <member name="M:NHapi.Base.Model.Varies.#ctor(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Creates new Varies.
            </summary>
            <param name="message">message to which this type belongs.</param>
            <param name="description">description of what this Type represents.</param>
        </member>
        <member name="P:NHapi.Base.Model.Varies.Data">
            <summary>
            <para>
            GET => Returns the data contained by this instance of Varies.  Returns a GenericPrimitive unless
            setData() has been called.
            </para>
            <para>
            SET => Sets the data contained by this instance of Varies.  If a data object already exists,
            then its values are copied to the incoming data object before the old one is replaced.
            For example, if getData() returns an ST with the value "19901012" and you call
            setData(new DT()), then subsequent calls to getData() will return the same DT, with the value
            set to "19901012".
            </para>
            </summary>
        </member>
        <member name="P:NHapi.Base.Model.Varies.ExtraComponents">
            <summary>Returns extra components from the underlying Type. </summary>
        </member>
        <member name="P:NHapi.Base.Model.Varies.Message">
            <returns> the message to which this Type belongs.
            </returns>
        </member>
        <member name="P:NHapi.Base.Model.Varies.Description">
            <returns> the description of what this Type represents.
            </returns>
        </member>
        <member name="M:NHapi.Base.Model.Varies.FixOBX5(NHapi.Base.Model.ISegment,NHapi.Base.Parser.IModelClassFactory,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Sets the data type of field 5 in the given OBX segment to the value of OBX-2.  The argument
            is a Segment as opposed to a particular OBX because it is meant to work with any version.
            <para>
            Note that if no value is present in OBX-2, or an invalid value is present in
            OBX-2, this method will throw an error.This behaviour can be corrected by using the
            <see cref="P:NHapi.Base.Parser.ParserOptions.DefaultObx2Type"/> and <see cref="P:NHapi.Base.Parser.ParserOptions.InvalidObx2Type"/>.
            </para>
            </summary>
            <param name="segment"><see cref="T:NHapi.Base.Model.ISegment"/> instance.</param>
            <param name="factory"><see cref="T:NHapi.Base.Parser.IModelClassFactory"/> to be used.</param>
            <param name="parserOptions"><see cref="T:NHapi.Base.Parser.ParserOptions"/> to be used.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If no value is present in OBX-2.</exception>
            <exception cref="T:NHapi.Base.HL7Exception">If an invalid value is present in OBX-2.</exception>
        </member>
        <member name="M:NHapi.Base.PackageManager.GetVersionPackagePath(System.String)">
            <summary> Returns the path to the base package for model elements of the given version
            - e.g. "NHapi.Model.VXXX".
            This package should have the packages datatype, segment, group, and message
            under it. The path ends in with a slash.
            </summary>
        </member>
        <member name="M:NHapi.Base.PackageManager.GetVersionPackageName(System.String)">
            <summary> Returns the package name for model elements of the given version - e.g.
            "NHapi.Base.Model.v24.".  This method
            is identical to. <code>getVersionPackagePath(...)</code> except that path
            separators are replaced with dots.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.CarriageReturnHexadecimal.X0D">
            <summary>
            will use \X0D\ as the escape sequence
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.CarriageReturnHexadecimal.X00D">
            <summary>
            will use \X00D\ as the escape sequence
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.CarriageReturnHexadecimal.X000d">
            <summary>
            will use \X000d\ as the escape sequence
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.ClassType">
            <summary>
            The class types for the default model factory.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.ClassType.Message">
            <summary>
            A message
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.ClassType.Segment">
            <summary>
            A segment
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.ClassType.Datatype">
            <summary>
            A datatype
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.ClassType.Group">
            <summary>
            A group
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.DefaultModelClassFactory">
             <summary> Default implementation of ModelClassFactory.  See PackageList() for configuration instructions.
            
             </summary>
             <author>  <a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a>
             </author>
             <version>  $Revision: 1.2 $ updated on $Date: 2005/05/24 18:15:39 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.PackageList(System.String)">
            <summary>
            <para>Lists all the packages (user-definable) where classes for standard and custom
            messages may be found.  Each package has sub-packages called "message",
            "group", "segment", and "datatype" in which classes for these message elements
            can be found.
            </para>
            <para>
            At a minimum, this method returns the standard package for the
            given version.  For example, for version 2.4, the package list contains. <code>
            NHapi.Base.Model.v24</code>.  In addition, user-defined packages may be specified
            for custom messages.
            </para>
            <para>
            If you define custom message classes, and want Parsers to be able to
            find them, you must register them as follows (otherwise you will get an exception when
            the corresponding messages are parsed).  For each HL7 version you want to support, you must
            put a text file on your class path, under the folder /custom_packages, named after the version.  For example,
            for version 2.4, you might put the file "custom_packages/2.4" in your application JAR.  Each line in the
            file should name a package to search for message classes of that version.  For example, if you
            work at foo.org, you might create a v2.4 message structure called "ZFO" and define it in the class.
            <code>org.foo.hl7.custom.message.ZFO</code>.
            </para>
            <para>
            In order for parsers to find this message
            class, you would need to enter the following line in custom_packages/2.4: org.foo.hl7.custom.
            </para>
            <para>
            Packages are searched in the order specified.  The standard package for a given version
            is searched last, allowing you to override the default implementation.  Please note that
            if you create custom classes for messages, segments, etc., their names must correspond exactly
            to their names in the message text.  For example, if you subclass the QBP segment in order to
            add your own fields, your subclass must also be called QBP. although it will obviously be in
            a different package.  To make sure your class is used instead of the default implementation,
            put your package in the package list.  User-defined packages are searched first, so yours
            will be found first and used.
            </para>
            <para>
            It is important to note that there can only be one implementation of a particular message
            structure (i.e. one class with the message structure name, regardless of its package) among
            the packages defined as per the. <code>PackageList()</code> method.  If there are duplicates
            (e.g. two ADT_A01 classes) the first one in the search order will always be used.  However,
            this restriction only applies to message classes, not segment classes, etc.  This is because
            classes representing parts of a message are referenced explicitly in the code for the message
            class, rather than being looked up (using findMessageClass() ) based on the String value of MSH-9.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.GetMessageClass(System.String,System.String,System.Boolean)">
            <summary>
            <para>
            Attempts to return the message class corresponding to the given name, by
            searching through default and user-defined (as per PackageList()) packages.
            Returns GenericMessage if the class is not found.
            </para>
            <para>
            It is important to note that there can only be one implementation of a particular message
            structure (i.e. one class with the message structure name, regardless of its package) among
            the packages defined as per the. <code>PackageList()</code> method.  If there are duplicates
            (e.g. two ADT_A01 classes) the first one in the search order will always be used.  However,
            this restriction only applies to message classes, not (normally) segment classes, etc.  This is because
            classes representing parts of a message are referenced explicitly in the code for the message
            class, rather than being looked up (using findMessageClass() ) based on the String value of MSH-9.
            The exception is that Segments may have to be looked up by name when they appear
            in unexpected locations (e.g. by local extension) -- see findSegmentClass().
            </para>
            <para>
            Note: the current implementation will be slow if there are multiple user-
            defined packages, because the JVM will try to load a number of non-existent
            classes every parse.  This should be changed so that specific classes, rather
            than packages, are registered by name.
            </para>
            </summary>
            <param name="theName">name of the desired structure in the form XXX_YYY.</param>
            <param name="theVersion">HL7 version (e.g. "2.3").</param>
            <param name="isExplicit">
            true if the structure was specified explicitly in MSH-9-3, false if it
            was inferred from MSH-9-1 and MSH-9-2.  If false, a lookup may be performed to find
            an alternate structure corresponding to that message type and event.
            </param>
            <returns>
            corresponding message subclass if found; GenericMessage otherwise.
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.GetGroupClass(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="theName"></param>
             <param name="theVersion"></param>
             <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.GetSegmentClass(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="theName"></param>
             <param name="theVersion"></param>
             <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.GetTypeClass(System.String,System.String)">
             <summary>
            
             </summary>
             <param name="theName"></param>
             <param name="theVersion"></param>
             <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.FindClass(System.String,System.String,NHapi.Base.Parser.ClassType)">
            <summary> Finds a message or segment class by name and version.</summary>
            <param name="name">the segment or message structure name.
            </param>
            <param name="version">the HL7 version.
            </param>
            <param name="type">'message', 'group', 'segment', or 'datatype'.
            </param>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultModelClassFactory.AddAssemblyName(System.String,System.String)">
            <summary>
            Add the assembly name to the class name.
            </summary>
            <param name="p"></param>
            <param name="classNameToTry"></param>
            <returns>Assembly name qualified name.</returns>
        </member>
        <member name="T:NHapi.Base.Parser.DefaultXMLParser">
            <summary>
            A default XMLParser. This class assigns segment elements (in an XML-encoded message)
            to Segment objects (in a Message object) using the name of a segment and the names
            of any groups in which the segment is nested. The names of group classes must correspond
            to the names of group elements (they must be identical except that a dot in the element
            name, following the message name, is replaced with an underscore, in order to constitute a
            valid class name).
            </summary>
            <remarks>
            At the time of writing, the group names in the XML spec are changing. Many of the group
            names have been automatically generated based on the group contents. However, these automatic
            names are gradually being replaced with manually assigned names. This process is expected to
            be complete by November 2002. As a result, mismatches are likely. Messages could be
            transformed prior to parsing (using XSLT) as a work-around. Alternatively the group class names
            could be changed to reflect updates in the XML spec.  Ultimately, HAPI group classes will be
            changed to correspond with the official group names, once these are all assigned.
            </remarks>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.#ctor">
            <summary>Creates a new instance of DefaultXMLParser. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>Creates a new instance of DefaultXMLParser. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.Main(System.String[])">
            <summary>Test harness. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.EncodeDocument(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc/>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.ParseDocument(System.Xml.XmlDocument,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc/>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.Parse(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.MakeGroupElementName(System.String,System.String)">
            <summary>
            Given the name of a message and a Group class, returns the corresponding group element name in an
            XML-encoded message. This is the message name and group name separated by a dot. For example,
            ADT_A01.INSURANCE.
            <para>
            If it looks like a segment name (ie: has 3 characters), no change is made.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.Parse(NHapi.Base.Model.IGroup,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary> Populates the given group object with data from the given group element, ignoring
            any unrecognized nodes.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.DefaultXMLParser.Encode(NHapi.Base.Model.IGroup,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Copies data from a <see cref="T:NHapi.Base.Model.IGroup"/> object into the corresponding <paramref name="groupElement"/>,
            creating any necessary child nodes.
            </summary>
            <param name="groupObject">The <see cref="T:NHapi.Base.Model.IGroup"/> to encode.</param>
            <param name="groupElement">The <see cref="T:System.Xml.XmlElement"/> to encode into.</param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If unable to encode <paramref name="groupObject"/>.</exception>
        </member>
        <member name="T:NHapi.Base.Parser.EncodingCharacters">
            <summary>
            Represents the set of special characters used to encode traditionally
            encoded HL7 messages.
            </summary>
            <author>Bryan Tripp (bryan_tripp@sourceforge.net).</author>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingCharacters.#ctor(System.Char,System.String)">
            <summary>
            Creates new EncodingCharacters object with the given character
            values. If the encodingCharacters argument is null, the default
            values are used.
            </summary>
            <param name="fieldSeparator">The field separator.</param>
            <param name="encodingCharacters">
            Consists of the characters that appear in
            MSH-2 (see section 2.8 of the HL7 spec). The characters are
            Component Separator, Repetition Separator, Escape Character, and
            Subcomponent Separator (in that order).
            </param>
            <exception cref="T:NHapi.Base.HL7Exception">If encoding characters are not unique.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingCharacters.#ctor(NHapi.Base.Parser.EncodingCharacters)">
            <summary>copies contents of "other". </summary>
        </member>
        <member name="P:NHapi.Base.Parser.EncodingCharacters.FieldSeparator">
            <summary>
            Returns the field separator.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.EncodingCharacters.ComponentSeparator">
            <summary>
            Returns the component separator.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.EncodingCharacters.RepetitionSeparator">
            <summary>
            Returns the repetition separator.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.EncodingCharacters.EscapeCharacter">
            <summary>
            Returns the escape character.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.EncodingCharacters.SubcomponentSeparator">
            <summary>
            Returns the subcomponent separator.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingCharacters.FromMessage(NHapi.Base.Model.IMessage)">
            <summary>
            Returns an instance using the MSH-1 and MSH-2 values of the given message.
            </summary>
            <param name="message">The message.</param>
            <returns>the encoding characters for this message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If either MSH-1 or MSH-2 are not populated.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingCharacters.ToString">
            <summary>
            Returns the encoding characters (not including field separator)
            as a string.
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.EncodingDetector">
            <summary>
            Detects message encoding (ER7 / XML) without relying on any
            external dependencies.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingDetector.AssertEr7Encoded(System.String)">
            <summary>
            Asserts the message is Er7 Encoded.
            </summary>
            <param name="message">Message to be examined.</param>
            <exception cref="T:System.ArgumentException">
            If the message is less than 4 characters long or the message does not start with MSH.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            If the 4th character of each segment was not a field delimiter.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingDetector.AssertXmlEncoded(System.String)">
            <summary>
            Asserts the message is XML encoded.
            </summary>
            <param name="message">Message to be examined.</param>
            <exception cref="T:System.ArgumentException">
            If <paramref name="message"/> does not contain "MSH.1>" or "MSH.2>".
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingDetector.IsEr7Encoded(System.String)">
            <summary>
            Returns true if the message is ER7 (pipe-and-hat) encoded.
            </summary>
            <param name="message">Message to be examined.</param>
            <returns>true if message is ER7-encoded.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingDetector.IsXmlEncoded(System.String)">
            <summary>
            Returns true if the message is XML encoded.
            <para>
            Note that this message does not perform a very robust check and does not
            validate for well-formedness.
            </para>
            <para>
            It is only intended to perform a simple check for XML vs.ER7 messages.
            </para>
            </summary>
            <param name="message">Message to be examined.</param>
            <returns>true if message is XML-encoded.</returns>
        </member>
        <member name="T:NHapi.Base.Parser.EncodingNotSupportedException">
            <summary> Represents a problem where a Parser does not support a particular HL7 encoding.
            Encodings include "|" (traditional) and "XML".
            </summary>
            <author>  Bryan Tripp (bryan_tripp@sourceforge.net).
            </author>
        </member>
        <member name="M:NHapi.Base.Parser.EncodingNotSupportedException.#ctor(System.String)">
            <summary> Constructs an. <code>EncodingNotSupportedException</code> with the specified detail message.</summary>
            <param name="msg">the detail message.
            </param>
        </member>
        <member name="T:NHapi.Base.Parser.Escape">
            <summary>
            Handles "escaping" and "un-escaping" of text according to the HL7 escape sequence rules
            defined in section 2.10 of the standard (version 2.4).  Currently, escape sequences for
            multiple character sets are unsupported.  The highlighting, hexadecimal, and locally
            defined escape sequences are also unsupported.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="F:NHapi.Base.Parser.Escape.VariousEncChars">
            <summary>
            Is used to cache multiple <see cref="T:NHapi.Base.Parser.Escape.EncodingLookups"/> keyed on <see cref="T:NHapi.Base.Parser.EncodingCharacters"/>
            for quick re-use.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.Escape.EscapeText(System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Escape string.
            </summary>
            <param name="text"></param>
            <param name="encodingCharacters"></param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.Escape.UnescapeText(System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Un-escape the string.
            </summary>
            <param name="text"></param>
            <param name="encodingCharacters"></param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.Escape.BuildEncodingLookups(NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Returns a <see cref="T:NHapi.Base.Parser.Escape.EncodingLookups"/> and caches for subsequent use
            using <see cref="T:NHapi.Base.Parser.EncodingCharacters"/> as keys.
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.IModelClassFactory">
             <summary> Looks up classes for message model components (e.g. concrete implementations of
             Message, Group, Segment).  A custom factory can be used to point to custom model
             components.
            
             </summary>
             <author>  <a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a>
             </author>
             <version>  $Revision: 1.1 $ updated on $Date: 2005/04/25 21:03:50 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="M:NHapi.Base.Parser.IModelClassFactory.GetMessageClass(System.String,System.String,System.Boolean)">
            <param name="theName">name of message.
            </param>
            <param name="theVersion">HL7 version.
            </param>
            <param name="isExplicit">true if the structure was specified explicitly in MSH-9-3, false if it
            was inferred from MSH-9-1 and MSH-9-2.  If false, a lookup may be performed to find
            an alternate structure corresponding to that message type and event.
            </param>
            <returns> a class that implements the specified message.
            </returns>
            <throws>  HL7Exception if the version if not recognized or an appropriate class can not be found. </throws>
        </member>
        <member name="M:NHapi.Base.Parser.IModelClassFactory.GetGroupClass(System.String,System.String)">
            <param name="theName">name of group.
            </param>
            <param name="theVersion">HL7 version.
            </param>
            <returns> a class that implements the specified group.
            </returns>
            <throws>  HL7Exception if the version if not recognized or an appropriate class can not be found. </throws>
        </member>
        <member name="M:NHapi.Base.Parser.IModelClassFactory.GetSegmentClass(System.String,System.String)">
            <param name="theName">name of segment.
            </param>
            <param name="theVersion">HL7 version.
            </param>
            <returns> a class that implements the specified segment.
            </returns>
            <throws>  HL7Exception if the version if not recognized or an appropriate class can not be found. </throws>
        </member>
        <member name="M:NHapi.Base.Parser.IModelClassFactory.GetTypeClass(System.String,System.String)">
            <param name="theName">name of type.
            </param>
            <param name="theVersion">HL7 version.
            </param>
            <returns> a class that implements the specified type.
            </returns>
            <throws>  HL7Exception if the version if not recognized or an appropriate class can not be found. </throws>
        </member>
        <member name="T:NHapi.Base.Parser.IStructureDefinition">
            <summary>
            Contains information about the composition of a given type of <see cref="T:NHapi.Base.Model.IStructure"/>.
            At runtime, parsers will use accessors provided by various structure types(messages, groups,
            segments) to determine the structure of a messages.Structure definitions are used
            to cache that information between parse calls.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.FirstSibling">
            <summary>
            Returns this structure's first sibling (in other words, its parent's first child).
            Returns <c>null</c> if this is the first sibling, or if this has no parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.NextLeaf">
            <summary>
            Returns the next leaf (segment) after this one, within the same
            group, only if one exists and this structure is also a leaf. Otherwise returns <c>null</c>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.NameAsItAppearsInParent">
            <summary>
            The name of the segment, as it is known to it's parent. This
            will differ from <see cref="P:NHapi.Base.Parser.IStructureDefinition.Name"/> in the case of multiple segments
            with the same name in a group, e.g.the two PID segments in ADT_A17,
            where the second one it known as PID2 to it's parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.Name">
            <summary>
            Returns the name of this structure.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.IsSegment">
            <summary>
            Returns true if this structure is a segment.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.IsRepeating">
            <summary>
            Returns true if this is a repeatable structure.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.HasChildren">
            <summary>
            Does this structure have children (i.e. is it not a segment).
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.IsFinalChildOfParent">
            <summary>
            Returns true if this structure is the final child of it's parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.IsChoiceElement">
            <summary>
            Returns true if this element a choice element <see ref="IGroup.IsChoiceElement"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.IsRequired">
            <summary>
            Returns true if this a required structure within it's parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.Children">
            <summary>
            Returns all children of this structure definition.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.Position">
            <summary>
            Returns the index of the position of this structure
            within it's parent's children.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.Parent">
            <summary>
            Returns the parent structure of this structure, if one exists.
            Otherwise, returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.NextSibling">
            <summary>
            Returns this structure's next sibling within it's parent, if any.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Parser.IStructureDefinition.FirstChild">
            <summary>
            structure definition of first child or <c>null</c> if there is no child.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.IStructureDefinition.GetNamesOfAllPossibleFollowingLeaves">
            <summary>
            Should only be called on a leaf node (segment).
            <para>Returns the names of all valid children which may follow
            this one at any level in the hierarchy (including as later
            siblings of parent structures to this one).
            </para>
            </summary>
            <returns>the names of all valid children which may follow this one.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.IStructureDefinition.GetAllPossibleFirstChildren">
            <summary>
            Returns the names of any possible children that could be the first
            required child of this group.
            <para>
            For instance, for the group below "ORC" and "OBR" would both be
            returned, as they are both potential first children of this group.
            </para>
            <para>
            Note that the name returned by <see cref="P:NHapi.Base.Parser.IStructureDefinition.Name"/>
            is also returned.
            </para>
            </summary>
            <returns>the names of any possible children that could be the first required child of this group.</returns>
            <example>For example:
            <code>
            ORDER_OBSERVATION
            {
            [ ORC ]
            OBR
            [ { NTE } ]
            [ CTD ]
            OBSERVATION
                {
                [ OBX ]
                [ { NTE } ]
                }
            OBSERVATION
            [ { FT1 } ]
            [ { CTI } ]
            }
            ORDER_OBSERVATION
            </code>
            </example>
        </member>
        <member name="M:NHapi.Base.Parser.IStructureDefinition.GetAllChildNames">
            <summary>
            Returns the names of all children of this structure, including first elements within child groups.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Parser.LegacyDefaultXMLParser">
            <summary>
            A default XMLParser. This class assigns segment elements (in an XML-encoded message)
            to Segment objects (in a Message object) using the name of a segment and the names
            of any groups in which the segment is nested. The names of group classes must correspond
            to the names of group elements (they must be identical except that a dot in the element
            name, following the message name, is replaced with an underscore, in order to constitute a
            valid class name).
            </summary>
            <remarks>
            At the time of writing, the group names in the XML spec are changing. Many of the group
            names have been automatically generated based on the group contents. However, these automatic
            names are gradually being replaced with manually assigned names. This process is expected to
            be complete by November 2002. As a result, mismatches are likely. Messages could be
            transformed prior to parsing (using XSLT) as a work-around. Alternatively the group class names
            could be changed to reflect updates in the XML spec.  Ultimately, HAPI group classes will be
            changed to correspond with the official group names, once these are all assigned.
            </remarks>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.#ctor">
            <summary>Creates a new instance of DefaultXMLParser. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>Creates a new instance of DefaultXMLParser. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.Main(System.String[])">
            <summary>Test harness. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.EncodeDocument(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary> <p>Creates an XML Document that corresponds to the given Message object. </p>
            <p>If you are implementing this method, you should create an XML Document, and insert XML Elements
            into it that correspond to the groups and segments that belong to the message type that your subclass
            of XMLParser supports.  Then, for each segment in the message, call the method
            <code>encode(Segment segmentObject, Element segmentElement)</code> using the Element for
            that segment and the corresponding Segment object from the given Message.</p>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.ParseDocument(System.Xml.XmlDocument,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary> <p>Creates and populates a Message object from an XML Document that contains an XML-encoded HL7 message.</p>
            <p>The easiest way to implement this method for a particular message structure is as follows:
            <ol><li>Create an instance of the Message type you are going to handle with your subclass
            of XMLParser</li>
            <li>Go through the given Document and find the Elements that represent the top level of
            each message segment. </li>
            <li>For each of these segments, call <code>parse(Segment segmentObject, Element segmentElement)</code>,
            providing the appropriate Segment from your Message object, and the corresponding Element.</li></ol>
            At the end of this process, your Message object should be populated with data from the XML
            Document.</p>
            </summary>
            <throws>  HL7Exception if the message is not correctly formatted. </throws>
            <throws>  EncodingNotSupportedException if the message encoded. </throws>
            <summary>     is not supported by this parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.Parse(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.MakeGroupElementName(System.String,System.String)">
            <summary>
            Given the name of a message and a Group class, returns the corresponding group element name in an
            XML-encoded message. This is the message name and group name separated by a dot. For example,
            ADT_A01.INSURANCE.
            <para>
            If it looks like a segment name (ie: has 3 characters), no change is made.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.Parse(NHapi.Base.Model.IGroup,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary> Populates the given group object with data from the given group element, ignoring
            any unrecognized nodes.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyDefaultXMLParser.Encode(NHapi.Base.Model.IGroup,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary> Copies data from a group object into the corresponding group element, creating any
            necessary child nodes.
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.LegacyPipeParser">
            <summary>
            This is a legacy implementation of the PipeParser and should not be used
            for new projects.
            <para>
            In versions of NHapi prior to version 3, a behaviour was corrected where unexpected segments
            would be placed at the tail end of the first segment group encountered.
            </para>
            Any legacy code which still depends on previous behaviour can use this
            implementation.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.#ctor">
            <summary>Creates a new LegacyPipeParser. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>Creates a new LegacyPipeParser. </summary>
        </member>
        <member name="P:NHapi.Base.Parser.LegacyPipeParser.DefaultEncoding">
            <summary>
            Gets the preferred encoding of this Parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Split(System.String,System.String)">
            <summary>
            Splits the given composite string into an array of components using
            the given delimiter.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Encode(NHapi.Base.Model.IType,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Encodes the given Type, using the given encoding characters.
            It is assumed that the Type represents a complete field rather than a component.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Encode(NHapi.Base.Model.IGroup,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Returns given group serialized as a pipe-encoded string - this method is called
            by encode(Message source, String encoding).
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.StripLeadingWhitespace(System.String)">
            <summary>
            Removes leading whitespace from the given string. This method was created to deal with frequent
            problems parsing messages that have been hand-written in windows. The intuitive way to delimit
            segments is to hit ENTER at the end of each segment, but this creates both a carriage return
            and a line feed, so to the parser, the first character of the next segment is the line feed.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetEncoding(System.String)">
            <summary> Returns a String representing the encoding of the given message, if
            the encoding is recognized.  For example if the given message appears
            to be encoded using HL7 2.x XML rules then "XML" would be returned.
            If the encoding is not recognized then null is returned.  That this
            method returns a specific encoding does not guarantee that the
            message is correctly encoded (e.g. well formed XML) - just that
            it is not encoded using any other encoding than the one returned.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetMessageStructure(System.String)">
            <deprecated> this method should not be public.
            </deprecated>
            <param name="message"></param>
            <returns>
            </returns>
            <throws>  HL7Exception. </throws>
            <throws>  EncodingNotSupportedException. </throws>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Parses a segment string and populates the given Segment object.  Unexpected fields are
            added as Varies' at the end of the segment.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a segment string and populates the given Segment object.  Unexpected fields are
            added as Varies' at the end of the segment.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetCriticalResponseData(System.String)">
            <summary> <p>Returns a minimal amount of data from a message string, including only the
            data needed to send a response to the remote system.  This includes the
            following fields:
            <list type="bullet">
            <item><description>field separator</description></item>
            <item><description>encoding characters</description></item>
            <item><description>processing ID</description></item>
            <item><description>message control ID</description></item>
            </list>
            This method is intended for use when there is an error parsing a message,
            (so the Message object is unavailable) but an error message must be sent
            back to the remote system including some of the information in the inbound
            message.  This method parses only that required information, hopefully
            avoiding the condition that caused the original error.  The other
            fields in the returned MSH segment are empty.</p>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetAckID(System.String)">
            <summary> For response messages, returns the value of MSA-2 (the message ID of the message
            sent by the sending system).  This value may be needed prior to main message parsing,
            so that (particularly in a multi-threaded scenario) the message can be routed to
            the thread that sent the request.  We need this information first so that any
            parse exceptions are thrown to the correct thread.
            Returns null if MSA-2 can not be found (e.g. if the message is not a
            response message).
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetVersion(System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.DoEncode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary> Formats a Message object into an HL7 message string using the given
            encoding.
            </summary>
            <throws>  HL7Exception if the data fields in the message do not permit encoding. </throws>
            <summary>      (e.g. required fields are null).
            </summary>
            <throws>  EncodingNotSupportedException if the requested encoding is not. </throws>
            <summary>      supported by this parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.DoEncode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary> Formats a Message object into an HL7 message string using this parser's
            default encoding ("VB").
            </summary>
            <throws>  HL7Exception if the data fields in the message do not permit encoding. </throws>
            <summary>      (e.g. required fields are null).
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.DoParse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
             <summary> Parses a message string and returns the corresponding Message
             object.  Unexpected segments added at the end of their group.
            
             </summary>
             <throws>  HL7Exception if the message is not correctly formatted. </throws>
             <throws>  EncodingNotSupportedException if the message encoded. </throws>
             <summary>      is not supported by this parser.
             </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetEncodingChars(System.String)">
            <summary> Returns object that contains the field separator and encoding characters
            for this message.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.StripExtraDelimiters(System.String,System.Char)">
            <summary>
            Removes unnecessary delimiters from the end of a field or segment.
            This seems to be more convenient than checking to see if they are needed
            while we are building the encoded string.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.IsDelimDefSegment(System.String)">
            <returns> true if the segment is MSH, FHS, or BHS.  These need special treatment
            because they define delimiters.
            </returns>
            <param name="theSegmentName">
            </param>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.Parse(NHapi.Base.Model.IType,System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary> Fills a field with values from an unparsed string representing the field.  </summary>
            <param name="destinationField">the field Type.
            </param>
            <param name="data">the field string (including all components and subcomponents; not including field delimiters).
            </param>
            <param name="encodingCharacters">the encoding characters used in the message.
            </param>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.GetStructure(System.String)">
            <returns>s the message structure from MSH-9-3.
            </returns>
        </member>
        <member name="T:NHapi.Base.Parser.LegacyPipeParser.MessageStructure">
            <summary>
            A struct for holding a message class string and a boolean indicating whether it
            was defined explicitly.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.ByDirectionPredicate.evaluate(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.LegacyPipeParser.ByDirectionPredicate.Evaluate(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Parser.LegacyXMLParser">
            <summary>
            Parses and encodes HL7 messages in XML form, according to HL7's normative XML encoding
            specification.  This is an abstract class that handles datatype and segment parsing/encoding,
            but not the parsing/encoding of entire messages.  To use the XML parser, you should create a
            subclass for a certain message structure.  This subclass must be able to identify the Segment
            objects that correspond to various Segment nodes in an XML document, and call the methods. <code>
            parse(Segment segment, ElementNode segmentNode)</code> and. <code>encode(Segment segment, ElementNode segmentNode)
            </code> as appropriate.  XMLParser uses the Xerces parser, which must be installed in your class path.
            </summary>
            <author>Bryan Tripp, Shawn Bellina.</author>
        </member>
        <member name="F:NHapi.Base.Parser.LegacyXMLParser.keepAsOriginalNodes">
            <summary>
            The nodes whose names match these strings will be kept as original,
            meaning that no white space trimming will occur on them.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.LegacyXMLParser.concatKeepAsOriginalNodes">
            <summary> All keepAsOriginalNodes names, concatenated by a pipe (|).</summary>
        </member>
        <member name="P:NHapi.Base.Parser.LegacyXMLParser.DefaultEncoding">
            <summary>
            Gets the preferred encoding of this Parser.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.LegacyXMLParser.KeepAsOriginalNodes">
            <summary>
            Sets the <i>keepAsOriginalNodes</i>.
            <para>
            The nodes whose names match the <i>keepAsOriginalNodes</i> will be kept as original,
            meaning that no white space trimming will occur on them.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.GetEncoding(System.String)">
            <summary>
            Returns a String representing the encoding of the given message, if
            the encoding is recognized.  For example if the given message appears
            to be encoded using HL7 2.x XML rules then "XML" would be returned.
            If the encoding is not recognized then null is returned.  That this
            method returns a specific encoding does not guarantee that the
            message is correctly encoded (e.g. well formed XML) - just that
            it is not encoded using any other encoding than the one returned.
            Returns null if the encoding is not recognized.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParseDocument(System.Xml.XmlDocument,System.String)">
            <summary> <p>Creates and populates a Message object from an XML Document that contains an XML-encoded HL7 message.</p>
            <p>The easiest way to implement this method for a particular message structure is as follows:
            <ol><li>Create an instance of the Message type you are going to handle with your subclass
            of XMLParser</li>
            <li>Go through the given Document and find the Elements that represent the top level of
            each message segment. </li>
            <li>For each of these segments, call <code>parse(Segment segmentObject, Element segmentElement)</code>,
            providing the appropriate Segment from your Message object, and the corresponding Element.</li></ol>
            At the end of this process, your Message object should be populated with data from the XML
            Document.</p>
            </summary>
            <throws>  HL7Exception if the message is not correctly formatted. </throws>
            <throws>  EncodingNotSupportedException if the message encoded. </throws>
            <summary>      is not supported by this parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParseDocument(System.Xml.XmlDocument,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary> <p>Creates and populates a Message object from an XML Document that contains an XML-encoded HL7 message.</p>
            <p>The easiest way to implement this method for a particular message structure is as follows:
            <ol><li>Create an instance of the Message type you are going to handle with your subclass
            of XMLParser</li>
            <li>Go through the given Document and find the Elements that represent the top level of
            each message segment. </li>
            <li>For each of these segments, call <code>parse(Segment segmentObject, Element segmentElement)</code>,
            providing the appropriate Segment from your Message object, and the corresponding Element.</li></ol>
            At the end of this process, your Message object should be populated with data from the XML
            Document.</p>
            </summary>
            <throws>  HL7Exception if the message is not correctly formatted. </throws>
            <throws>  EncodingNotSupportedException if the message encoded. </throws>
            <summary>      is not supported by this parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.EncodeDocument(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary> <p>Creates an XML Document that corresponds to the given Message object. </p>
            <p>If you are implementing this method, you should create an XML Document, and insert XML Elements
            into it that correspond to the groups and segments that belong to the message type that your subclass
            of XMLParser supports.  Then, for each segment in the message, call the method
            <code>encode(Segment segmentObject, Element segmentElement)</code> using the Element for
            that segment and the corresponding Segment object from the given Message.</p>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Parse(NHapi.Base.Model.ISegment,System.Xml.XmlElement)">
            <summary> Populates the given Segment object with data from the given XML Element.</summary>
            <throws>  HL7Exception if the XML Element does not have the correct name and structure. </throws>
            <summary>      for the given Segment, or if there is an error while setting individual field values.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Parse(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary> Populates the given Segment object with data from the given XML Element.</summary>
            <throws>  HL7Exception if the XML Element does not have the correct name and structure. </throws>
            <summary>      for the given Segment, or if there is an error while setting individual field values.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement)">
            <summary> Populates the given Element with data from the given Segment, by inserting
            Elements corresponding to the Segment's fields, their components, etc.  Returns
            true if there is at least one data value in the segment.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary> Populates the given Element with data from the given Segment, by inserting
            Elements corresponding to the Segment's fields, their components, etc.  Returns
            true if there is at least one data value in the segment.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Parse(NHapi.Base.Model.IType,System.Xml.XmlElement)">
            <summary> Populates the given Type object with data from the given XML Element.</summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.GetCriticalResponseData(System.String)">
            <summary> <p>Returns a minimal amount of data from a message string, including only the
            data needed to send a response to the remote system.  This includes the
            following fields:
            <list type="bullet">
            <item><description>field separator</description></item>
            <item><description>encoding characters</description></item>
            <item><description>processing ID</description></item>
            <item><description>message control ID</description></item>
            </list>
            This method is intended for use when there is an error parsing a message,
            (so the Message object is unavailable) but an error message must be sent
            back to the remote system including some of the information in the inbound
            message.  This method parses only that required information, hopefully
            avoiding the condition that caused the original error.</p>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.GetAckID(System.String)">
            <summary>
            For response messages, returns the value of MSA-2 (the message ID of the message
            sent by the sending system). This value may be needed prior to main message parsing,
            so that (particularly in a multi-threaded scenario) the message can be routed to
            the thread that sent the request. We need this information first so that any
            parse exceptions are thrown to the correct thread. Implementers of Parsers should
            take care to make the implementation of this method very fast and robust.
            Returns null if MSA-2 can not be found (e.g. if the message is not a
            response message). Trims whitespace from around the MSA-2 field.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.GetVersion(System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.KeepAsOriginal(System.Xml.XmlNode)">
            <summary>
            Checks if a node content should be kept as original (ie.: whitespaces won't be removed).
            </summary>
            <param name="node">The target node.</param>
            <returns>
            <c>true</c> if whitespaces should not be removed from node content; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.RemoveWhitespace(System.String)">
            <summary>
            Removes all unnecessary whitespace from the given String (intended to be used with Primitive values).
            This includes leading and trailing whitespace, and repeated space characters. Carriage returns,
            line feeds, and tabs are replaced with spaces.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.DoParse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a message string and returns the corresponding Message
            object. This method checks that the given message string is XML encoded, creates an
            XML Document object (using Xerces) from the given String, and calls the abstract
            method <see cref="M:NHapi.Base.Parser.LegacyXMLParser.ParseDocument(System.Xml.XmlDocument,System.String)"/>.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.DoEncode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a Message object into an HL7 message string using the given encoding.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.DoEncode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a Message object into an HL7 message string using this parser's
            default encoding (XML encoding). This method calls the abstract method.
            <code>encodeDocument(...)</code> in order to obtain XML Document object
            representation of the Message, then serializes it to a String.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParseLeaf(System.String,System.String,System.Int32)">
            <summary>
            Attempts to retrieve the value of a leaf tag without using DOM or SAX.
            This method searches the given message string for the given tag name, and returns
            everything after the given tag and before the start of the next tag.  Whitespace
            is stripped.  This is intended only for lead nodes, as the value is considered to
            end at the start of the next tag, regardless of whether it is the matching end
            tag or some other nested tag.
            </summary>
            <param name="message">a string message in XML form.</param>
            <param name="tagName">the name of the XML tag, e.g. "MSA.2".</param>
            <param name="startAt">the character location at which to start searching.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the tag can not be found.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParseComposite(NHapi.Base.Model.IComposite,System.Xml.XmlElement)">
            <summary> Populates a Composite type by looping through it's children, finding corresponding
            Elements among the children of the given Element, and calling parse(Type, Element) for
            each.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.MakeElementName(NHapi.Base.Model.ISegment,System.Int32)">
            <summary>
            Returns the expected XML element name for the given child of the given Segment.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.MakeElementName(NHapi.Base.Model.IComposite,System.Int32)">
            <summary>
            Returns the expected XML element name for the given child of the given Composite.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.Encode(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:System.Xml.XmlElement"/> with data from the given <see cref="T:NHapi.Base.Model.IType"/>, by inserting
            XmlElements corresponding to the Type's components and values.
            </summary>
            <returns>
            <see langword="true" /> if the given type contains a value (i.e. for Primitives, if
            <see cref="P:NHapi.Base.Model.IPrimitive.Value"/> doesn't return null, and for Composites, if at least one underlying
            Primitive doesn't return null).
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.EncodeVaries(NHapi.Base.Model.Varies,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Encodes a Varies type by extracting it's data field and encoding that.
            </summary>
            <returns><see langword="true" /> if the data field (or one of its components) contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.EncodePrimitive(NHapi.Base.Model.IPrimitive,System.Xml.XmlElement)">
            <summary>
            Encodes a Primitive in XML by adding it's value as a child of the given Element.
            </summary>
            <returns><see langword="true" /> if the given Primitive contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.EncodeComposite(NHapi.Base.Model.IComposite,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Encodes a Composite in XML by looping through it's components, creating new
            children for each of them (with the appropriate names) and populating them by
            calling <see cref="M:NHapi.Base.Parser.LegacyXMLParser.Encode(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/> using these children.
            </summary>
            <returns><see langword="true" /> if at least one component contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParseVaries(NHapi.Base.Model.Varies,System.Xml.XmlElement)">
            <summary>
            Parses an XML element into a Varies by determining whether the element is primitive or
            composite, calling setData() on the Varies with a new generic primitive or composite as appropriate,
            and then calling parse again with the new Type object.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.HasChildElement(System.Xml.XmlElement)">
            <summary>Returns true if any of the given element's children are elements. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.LegacyXMLParser.ParsePrimitive(NHapi.Base.Model.IPrimitive,System.Xml.XmlElement)">
            <summary>Parses a primitive type by filling it with text child, if any. </summary>
        </member>
        <member name="F:NHapi.Base.Parser.LineFeedHexadecimal.X0A">
            <summary>
            will use \X0A\ as the escape sequence
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.LineFeedHexadecimal.X00A">
            <summary>
            will use \X00A\ as the escape sequence
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.LineFeedHexadecimal.X000a">
            <summary>
            will use \X000a\ as the escape sequence
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.MessageIterator">
            <summary>
            Iterates over all defined nodes (ie segments, groups) in a message,
            regardless of whether they have been instantiated previously.  This is a
            tricky process, because the number of nodes is infinite, due to infinitely
            repeating segments and groups.  See. <code>next()</code> for details on
            how this is handled.
            <para>
            This implementation assumes that the first segment in each group is present (as per
            HL7 rules).  Specifically, when looking for a segment location, an empty group that has
            a spot for the segment will be overlooked if there is anything else before that spot.
            This may result in surprising (but sensible) behaviour if a message is missing the
            first segment in a group.
            </para>
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.#ctor(NHapi.Base.Model.IMessage,NHapi.Base.Parser.IStructureDefinition,System.String,System.Boolean,NHapi.Base.Parser.ParserOptions)">
            <summary>Creates a new instance of MessageIterator. </summary>
        </member>
        <member name="P:NHapi.Base.Parser.MessageIterator.Current">
            <summary>
            <para>
            Returns the next node in the message.  Sometimes the next node is
            ambiguous.  For example at the end of a repeating group, the next node
            may be the first segment in the next repetition of the group, or the
            next sibling, or an undeclared segment locally added to the group's end.
            Cases like this are disambiguated using <see cref="P:NHapi.Base.Parser.MessageIterator.Direction"/>, which returns
            the name of the structure that we are "iterating towards".
            Usually we are "iterating towards" a segment of a certain name because we
            have a segment string that we would like to parse into that node.
            Here are the rules:
            </para>
            <list type="bullet">
            <item><description>If at a group, next means first child.</description></item>
            <item><description>If at a non-repeating segment, next means next "position"</description></item>
            <item><description>If at a repeating segment: if segment name matches
            direction then next means next rep, otherwise next means next "position".</description></item>
            <item><description>If at a segment within a group (not at the end of the group), next "position"
            means next sibling</description></item>
            <item><description>If at the end of a group: If name of group or any of its "first
            descendants" matches direction, then next position means next rep of group.  Otherwise
            if direction matches name of next sibling of the group, or any of its first
            descendants, next position means next sibling of the group.  Otherwise, next means a
            new segment added to the group (with a name that matches "direction").</description></item>
            <item><description>"First descendants" means first child, or first child of the first child,
            or first child of the first child of the first child, etc.</description></item>
            </list>
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.MessageIterator.Direction">
            <summary>
            The direction.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.MoveNext">
            <summary>
            Returns true if another object exists in the iteration sequence.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Reset">
            <summary>
            Reset the iterator.
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.MessageIterator.Index">
            <summary> An index of a child structure within a group, consisting of the name and rep of
            of the child.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.MessageIterator.Index.name">
            <summary>
            The name.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.MessageIterator.Index.rep">
            <summary>
            The repetition.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Index.#ctor(System.String,System.Int32)">
            <summary>
            The index.
            </summary>
            <param name="name">name.</param>
            <param name="rep">repetition.</param>
        </member>
        <member name="P:NHapi.Base.Parser.MessageIterator.Index.Name">
            <summary>
            Gets or sets the name.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.MessageIterator.Index.Rep">
            <summary>
            Gets or sets the repetition.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Index.Equals(System.Object)">
            <summary>
            Override equals.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Index.GetHashCode">
            <summary>
            Override has code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Index.ToString">
            <summary>
            Override to string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Parser.MessageIterator.Position">
            <summary> A structure position within a message. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.MessageIterator.Position.ToString">
            <summary>
            Override to string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Parser.NonStandardStructureDefinition">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Parser.ParserBase">
            <summary>
            Parses HL7 message Strings into HL7 Message objects and
            encodes HL7 Message objects into HL7 message Strings.
            </summary>
            <author>Bryan Tripp (bryan_tripp@sourceforge.net).</author>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.#ctor">
            <summary>
            Uses DefaultModelClassFactory for model class lookup.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <param name="theFactory">
            custom factory to use for model class lookup.
            </param>
        </member>
        <member name="P:NHapi.Base.Parser.ParserBase.Factory">
            <summary>
            Gets the factory used by this Parser for model class lookup.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.ParserBase.ValidationContext">
            <summary>
            Gets or sets the set of validation rules that is applied to messages parsed or encoded by this parser.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.ParserBase.DefaultEncoding">
            <summary>
            Gets the preferred encoding of this Parser.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.ParserBase.MessageStructures">
            <summary>
            Returns event->structure maps.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.MakeControlMSH(System.String,NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Creates a version-specific MSH object and returns it as a version-independent
            MSH interface.
            </summary>
            <param name="version">HL7 Version.</param>
            <param name="factory">Model class factory to be used.</param>
            <returns>MSH segment for this version returned by the model class factory.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If no matching segment could be found.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.ValidVersion(System.String)">
            <summary>
            Returns true if the given string represents a valid 2.x version.
            Valid versions include "2.0", "2.0D", "2.1", "2.2", "2.3", "2.3.1", "2.4", "2.5".
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetMessageStructureForEvent(System.String,System.String)">
            <summary>
            Given a concatenation of message type and event (e.g. ADT_A04), and the
            version, finds the corresponding message structure (e.g. ADT_A01).  This
            is needed because some events share message structures, although it is not needed
            when the message structure is explicitly valued in MSH-9-3.
            If no mapping is found, returns the original name.
            </summary>
            <param name="name">A concatenation of message type and event (e.g. ADT_A04).</param>
            <param name="version">The name of the HL7 version to which the message belongs (eg "2.5").</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if there is an error retrieving the map, or if the given version is invalid.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(System.String)">
            <summary>
            Parses a message string and returns the corresponding Message object. Uses the default
            <see cref="T:NHapi.Base.Parser.ParserOptions"/>.
            </summary>
            <param name="message">A string that contains an HL7 message.</param>
            <returns>A <see cref="T:NHapi.Base.Model.IMessage"/> object parsed from the given string.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the message is not correctly formatted.</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">If the message encoded is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a message string and returns the corresponding Message object.
            </summary>
            <param name="message">A string that contains an HL7 message.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <returns>A <see cref="T:NHapi.Base.Model.IMessage"/> object parsed from the given string.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the message is not correctly formatted.</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">If the message encoded is not supported by this parser.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="parserOptions"/> is null.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(System.String,System.String)">
            <summary>
            Parse a message to a specific assembly. Uses the default <see cref="T:NHapi.Base.Parser.ParserOptions"/>.
            </summary>
            <param name="message">A string that contains an HL7 message.</param>
            <param name="version">the name of the HL7 version to which the message belongs (eg "2.5").</param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parse a message to a specific assembly.
            </summary>
            <param name="message">A string that contains an HL7 message.</param>
            <param name="version">the name of the HL7 version to which the message belongs (eg "2.5").</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="parserOptions"/> is null.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Parses a particular message and returns the encoded structure. Uses the default
            <see cref="T:NHapi.Base.Parser.ParserOptions"/>.
            </summary>
            <param name="message">The message to encode.</param>
            <param name="string">The string to parse.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If there is a problem encoding.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Parse(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a particular message and returns the encoded structure.
            </summary>
            <param name="message">The message to encode.</param>
            <param name="string">The string to parse.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If there is a problem encoding.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage,System.String)">
            <summary>
            Formats a <see cref="T:NHapi.Base.Model.IMessage"/> object into an HL7 message string using the given encoding.
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IMessage"/> object from which to construct an encoded message string.</param>
            <param name="encoding">the name of the HL7 encoding to use (eg "XML"; most implementations support only
            one encoding).
            </param>
            <returns>The encoded message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a <see cref="T:NHapi.Base.Model.IMessage"/> object into an HL7 message string using the given encoding.
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IMessage"/> object from which to construct an encoded message string.</param>
            <param name="encoding">the name of the HL7 encoding to use (eg "XML"; most implementations support only
            one encoding).
            </param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns>The encoded message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage)">
            <summary>
            Formats a Message object into an HL7 message string using this parsers
            default encoding.
            </summary>
            <param name="source">
            A Message object from which to construct an encoded message string.
            </param>
            <returns>The encoded message.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a Message object into an HL7 message string using this parsers
            default encoding.
            </summary>
            <param name="source">
            A Message object from which to construct an encoded message string.
            </param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns>The encoded message.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetEncoding(System.String)">
            <summary>
            Returns a String representing the encoding of the given message, if
            the encoding is recognized.
            <para>
            For example if the given message appears
            to be encoded using HL7 2.x XML rules then "XML" would be returned.
            </para>
            <para>
            If the encoding is not recognized then null is returned.
            </para>
            That this method returns a specific encoding does not guarantee that the
            message is correctly encoded (e.g. well formed XML) - just that
            it is not encoded using any other encoding than the one returned.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns>
            "XML" or "ER7" or null if the encoding is not recognized.
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.SupportsEncoding(System.String)">
            <summary>
            Returns true if and only if the given encoding is supported
            by this Parser.
            </summary>
            <param name="encoding">The encoding, "XML" or "ER7".</param>
            <returns>true if this parser supports parsing message encoded this way.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetCriticalResponseData(System.String)">
            <summary>
            Returns a minimal amount of data from a message string, including only the
            data needed to send a response to the remote system.
            <para>This includes the following fields:</para>
            <list type="bullet">
            <item><description>field separator</description></item>
            <item><description>encoding characters</description></item>
            <item><description>processing ID</description></item>
            <item><description>message control ID</description></item>
            </list>
            This method is intended for use when there is an error parsing a message,
            (so the Message object is unavailable) but an error message must be sent
            back to the remote system including some of the information in the inbound
            message.
            <para>This method parses only that required information, hopefully
            avoiding the condition that caused the original error.
            </para>
            The other fields in the returned MSH segment are empty.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetAckID(System.String)">
            <summary>
            For response messages, returns the value of MSA-2 (the message ID of the message
            sent by the sending system).
            <para>
            This value may be needed prior to main message parsing,
            so that (particularly in a multi-threaded scenario) the message can be routed to
            the thread that sent the request.
            </para>
            We need this information first so that any
            parse exceptions are thrown to the correct thread.
            <para>
            Implementers of Parsers should
            take care to make the implementation of this method very fast and robust.
            </para>
            </summary>
            <returns>
            null if MSA-2 can not be found (e.g. if the message is not a
            response message).
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetVersion(System.String)">
            <summary>
            Returns the version ID (MSH-12) from the given message, without fully parsing the message.
            The version is needed prior to parsing in order to determine the message class
            into which the text of the message should be parsed.
            </summary>
            <param name="message">The message to inspect.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the version field can not be found.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.GetVersion(System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Returns the version ID (MSH-12) from the given message, without fully parsing the message.
            The version is needed prior to parsing in order to determine the message class
            into which the text of the message should be parsed.
            </summary>
            <param name="message">The message to inspect.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the version field can not be found.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.DoEncode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Called by <see cref="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)"/> to perform implementation-specific encoding work.
            </summary>
            <param name="source">a Message object from which to construct an encoded message string.</param>
            <param name="encoding">the name of the HL7 encoding to use (eg "XML"; most implementations support only one encoding).</param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns>The encoded message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.DoEncode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Called by <see cref="M:NHapi.Base.Parser.ParserBase.Encode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)"/> to perform implementation-specific encoding work.
            </summary>
            <param name="source">a Message object from which to construct an encoded message string.</param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns>The encoded message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.DoParse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Called by <see cref="M:NHapi.Base.Parser.ParserBase.Parse(System.String,System.String)"/> to perform implementation-specific parsing work.
            </summary>
            <param name="message">a String that contains an HL7 message.</param>
            <param name="version">the name of the HL7 version to which the message belongs (eg "2.5").</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <returns>A HAPI Message object parsed from the given String.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="parserOptions"/> is null.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.ParserBase.InstantiateMessage(System.String,System.String,System.Boolean)">
            <summary>
            Note that the validation context of the resulting message is set to this parsers validation
            context. The validation context is used within <see cref="P:NHapi.Base.Model.IPrimitive.Value"/>.
            </summary>
            <param name="theName">name of the desired structure in the form XXX_YYY.</param>
            <param name="theVersion">HL7 version (e.g. "2.3").</param>
            <param name="isExplicit">
            true if the structure was specified explicitly in MSH-9-3, false if it
            was inferred from MSH-9-1 and MSH-9-2.  If false, a lookup may be performed to find
            an alternate structure corresponding to that message type and event.
            </param>
            <returns>a Message instance.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown when the version is not recognized or no appropriate class can be found or the Message.</exception>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.AllowUnknownVersions">
            <summary>
            <para>
            If set to <see langword="true"/>, the parser will allow messages to parse, even if they
            contain a version which is not known to the parser.
            </para>
            <para>
            When operating in this mode, if a message arrives which an unknown version string, the
            parser will attempt to parse it using a <see cref="T:NHapi.Base.Model.GenericMessage"/> class
            instead of a specific nhapi structure class.
            </para>
            </summary>
            <remarks>The default value is <see langword="false"/>.</remarks>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.DefaultObx2Type">
            <summary>
            If this property is set, the value provides a default datatype ("ST",
            "NM", etc) for an OBX segment with a missing OBX-2 value. This is useful
            when parsing messages from systems which do not correctly populate OBX-2.
            </summary>
            <example>
            <para>
            For example, if this property is set to "ST", and the following OBX
            segment is encountered:
            <code>
            OBX|||||This is a value
            </code>
            It will be parsed as though it had read:
            <code>
            OBX||ST|||This is a value
            </code>
            </para>
            </example>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.InvalidObx2Type">
            <summary>
            If this property is set, the value provides a default datatype ("ST",
            "NM", etc) for an OBX segment with an invalid OBX-2 value. This is useful
            when parsing messages from systems which do not correctly populate OBX-2.
            </summary>
            <example>
            <para>
            For example, if this property is set to "ST", and the following OBX
            segment is encountered:
            <code>
            OBX||INVALID|||This is a value
            </code>
            It will be parsed as though it had read:
            <code>
            OBX||ST|||This is a value
            </code>
            </para>
            </example>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.UnexpectedSegmentBehaviour">
            <summary>
            Gets or Sets the behaviour to use when parsing a message and a nonstandard segment is found.
            </summary>
            <remarks>The default value is <see cref="F:NHapi.Base.Parser.UnexpectedSegmentBehaviour.AddInline"/>.</remarks>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.NonGreedyMode">
             <summary>
             If set to <see langword="true"/>, pipe parser will be put in non-greedy mode. This setting
             applies only to <see cref="T:NHapi.Base.Parser.PipeParser"/> and will have no effect on <see cref="T:NHapi.Base.Parser.XMLParser"/>.
             </summary>
            
             <remarks>
             <para>The default value is <see langword="false"/>.</para>
             <para>
                 In non-greedy mode, if the message structure being parsed has an ambiguous choice of where to put a segment
                 because there is a segment matching the current segment name in both a later position in the message, and
                 in an earlier position as a part of a repeating group, the earlier position will be chosen.
             </para>
             <para>
                 This mode is useful for example when parsing OML^O21 messages containing multiple orders.
             </para>
             </remarks>
            
             <example>
             <para>
                 This is perhaps best explained with an example. Consider the following structure:
                 <code>
                     MSH
                     GROUP_1 (start)
                     {
                        AAA
                        BBB
                        GROUP_2 (start)
                        {
                           AAA
                        }
                        GROUP_2 (end)
                     }
                     GROUP_1 (end)
                 </code>
             </para>
             <para>
                 For the above example, consider a message containing the following segments:
                 <code>
                     MSH
                     AAA
                     BBB
                     AAA
                 </code>
             </para>
             <para>
                 In this example, when the second AAA segment is encountered, there are two possible choices. It would be
                 placed in GROUP_2, or it could be placed in a second repetition of GROUP_1. By default it will be placed in
                 GROUP_2, but in non-greedy mode it will be put in a new repetition of GROUP_1.
             </para>
             </example>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.IncludeLongNameInEncodedXml">
            <summary>
            Gets or Sets flag which allows the Description attribute 'LongName' to be added in encoded xml with counter position.
            </summary>
            <example>
            <code>
            <![CDATA[
            <MSH.1 LongName="Field Separator">1</MSH.1>
            <MSH.2 LongName="Encoding Characters">2</MSH.2>
            ]]>
            </code>
            </example>
            <remarks>The default value is <see langword="false"/>.</remarks>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.DisableWhitespaceTrimmingOnAllXmlNodes">
            <summary>
            <para>
            If set to <see langword="true"/>, the <see cref="T:NHapi.Base.Parser.XMLParser"/> is configured to treat all whitespace
            text nodes as literal, meaning that line breaks, tabs, multiple spaces, etc. will be preserved.
            </para>
            <para>
            If set to <see langword="false"/>, any values passed to <see cref="P:NHapi.Base.Parser.ParserOptions.XmlNodeNamesToDisableWhitespaceTrimming"/>
            will be superseded since all whitespace will treated as literal.
            </para>
            </summary>
            <remarks>The default value is <see langword="false"/>.</remarks>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.XmlNodeNamesToDisableWhitespaceTrimming">
            <summary>
            <para>
            Configures the <see cref="T:NHapi.Base.Parser.XMLParser"/> to treat all whitespace within the given <see cref="T:System.Collections.Generic.HashSet`1"/>
            as literal, meaning that line breaks, tabs, multiple spaces, etc. will be preserved.
            </para>
            </summary>
            <remarks>The default value is an Empty <see cref="T:System.Collections.Generic.HashSet`1"/>.</remarks>
        </member>
        <member name="P:NHapi.Base.Parser.ParserOptions.PrettyPrintEncodedXml">
            <summary>
            <para>
            If set to <see langword="true"/>, the <see cref="T:NHapi.Base.Parser.XMLParser"/> will attempt to pretty-print the XML
            they generate.
            </para>
            <para>
            This means the messages will look nicer to humans, but may take up slightly more space/bandwidth.
            </para>
            </summary>
            <remarks>The default value is <see langword="true"/>.</remarks>
        </member>
        <member name="T:NHapi.Base.Parser.PipeParser">
            <summary>
            An implementation of Parser that supports traditionally encoded (ie delimited with characters
            like |, ^, and ~) HL7 messages.  Unexpected segments and fields are parsed into generic elements
            that are added to the message.
            </summary>
            <author>Bryan Tripp (bryan_tripp@sourceforge.net).</author>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.#ctor">
            <summary>
            Creates a new PipeParser.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.#ctor(NHapi.Base.Parser.IModelClassFactory)">
            <summary>
            Creates a new PipeParser.
            <param name="factory">Looks up classes for message model components.</param>
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.PipeParser.DefaultEncoding">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Split(System.String,System.String)">
            <summary>
            Splits the given composite string into an array of components using
            the given delimiter.
            </summary>
            <param name="composite">Encoded composite string.</param>
            <param name="delimiter">Delimiter to split upon.</param>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Encode(NHapi.Base.Model.IType,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Returns given <see cref="T:NHapi.Base.Model.IType"/> as a pipe-encoded string, using the given encoding characters.
            <para>
            It is assumed that the Type represents a complete field rather than a component.
            </para>
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IType"/> object from which to construct an encoded string.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <returns>The encoded type.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the group do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Encode(NHapi.Base.Model.IGroup,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Returns given <see cref="T:NHapi.Base.Model.IGroup"/> as a pipe-encoded string, using the given encoding characters.
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IGroup"/> object from which to construct an encoded string.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <returns>The encoded group.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the group do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Encode(NHapi.Base.Model.ISegment,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Formats a <see cref="T:NHapi.Base.Model.IMessage"/> object into an HL7 message string using the given encoding.
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IMessage"/> object from which to construct an encoded message string.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <returns>The encoded message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.StripLeadingWhitespace(System.String)">
            <summary>
            Removes leading whitespace from the given string. This method was created to deal with frequent
            problems parsing messages that have been hand-written in windows. The intuitive way to delimit
            segments is to hit ENTER at the end of each segment, but this creates both a carriage return
            and a line feed, so to the parser, the first character of the next segment is the line feed.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetEncoding(System.String)">
            <summary>
            Returns a string representing the encoding of the given message, if the
            encoding is recognised.
            <para>
            For example if the given message appears to be
            encoded using HL7 2.x XML rules then "XML" would be returned.
            </para>
            <para>
            If the encoding is not recognised then null is returned.
            </para>
            That this method returns a specific encoding does not guarantee that the
            message is correctly encoded (e.g. well formed XML) - just that
            it is not encoded using any other encoding than the one returned.
            </summary>
            <param name="message">Message to be examined.</param>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetMessageStructure(System.String)">
            <deprecated> this method should not be public.
            </deprecated>
            <param name="message">
            </param>
            <returns>
            </returns>
            <throws>  HL7Exception. </throws>
            <throws>  EncodingNotSupportedException. </throws>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary>
            Parses a segment string and populates the given Segment object.
            <para>
            Unexpected fields are added as Varies' at the end of the segment.
            </para>
            </summary>
            <param name="destination">Segment to parse the segment string into.</param>
            <param name="segment">Encoded segment.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a segment string and populates the given Segment object.
            <para>
            Unexpected fields are added as Varies' at the end of the segment.
            </para>
            </summary>
            <param name="destination">Segment to parse the segment string into.</param>
            <param name="segment">Encoded segment.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters,System.Int32)">
            <summary>
            Parses a segment string and populates the given Segment object.
            <para>
            Unexpected fields are added as Varies' at the end of the segment.
            </para>
            </summary>
            <param name="destination">Segment to parse the segment string into.</param>
            <param name="segment">Encoded segment.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <param name="repetition">The repetition number of this segment within its group.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.ISegment,System.String,NHapi.Base.Parser.EncodingCharacters,System.Int32,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a segment string and populates the given Segment object.
            <para>
            Unexpected fields are added as Varies' at the end of the segment.
            </para>
            </summary>
            <param name="destination">Segment to parse the segment string into.</param>
            <param name="segment">Encoded segment.</param>
            <param name="encodingChars">Encoding characters to be used.</param>
            <param name="repetition">The repetition number of this segment within its group.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the given string does not contain the given segment or if the string is not encoded properly.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetCriticalResponseData(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetAckID(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetVersion(System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.DoEncode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.DoEncode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.DoParse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetEncodingChars(System.String)">
            <summary>
            Returns object that contains the field separator and encoding characters
            for this message.
            <para>
            There's an additional character starting with v2.7 (truncation), but we will
            accept it in messages of any version.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.StripExtraDelimiters(System.String,System.Char)">
            <summary>
            Removes unnecessary delimiters from the end of a field or segment.
            This seems to be more convenient than checking to see if they are needed
            while we are building the encoded string.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.IsDelimDefSegment(System.String)">
            <returns>
            true if the segment is MSH, FHS, or BHS.
            These need special treatment because they define delimiters.
            </returns>
            <param name="theSegmentName"></param>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.Parse(NHapi.Base.Model.IType,System.String,NHapi.Base.Parser.EncodingCharacters)">
            <summary> Fills a field with values from an unparsed string representing the field.  </summary>
            <param name="destinationField">the field Type.
            </param>
            <param name="data">the field string (including all components and subcomponents; not including field delimiters).
            </param>
            <param name="encodingCharacters">the encoding characters used in the message.
            </param>
        </member>
        <member name="M:NHapi.Base.Parser.PipeParser.GetStructure(System.String)">
            <returns>
            The message structure from MSH-9-3.
            </returns>
        </member>
        <member name="T:NHapi.Base.Parser.PipeParser.MessageStructure">
            <summary>
            A struct for holding a message class string and a boolean indicating whether it
            was defined explicitly.
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.StructureDefinition">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Parser.UnexpectedSegmentBehaviour">
            <summary>
            Defines the behaviour to use when an unexpected segment is discovered while parsing a message.
            </summary>
            <remarks>See <see cref="P:NHapi.Base.Parser.ParserOptions.UnexpectedSegmentBehaviour"/>.</remarks>
        </member>
        <member name="F:NHapi.Base.Parser.UnexpectedSegmentBehaviour.AddInline">
            <summary>
            Add the segment as a <see cref="M:NHapi.Base.Model.IGroup.AddNonstandardSegment(System.String,System.Int32)"/>
            at the current location, even if the current location is in a child group within the message.
            </summary>
            <remarks>This is the default.</remarks>
        </member>
        <member name="F:NHapi.Base.Parser.UnexpectedSegmentBehaviour.DropToRoot">
            <summary>
            Return the parser back to the root of the message (even if the last segment was in a group) and add
            the unexpected segment as a <see cref="M:NHapi.Base.Model.IGroup.AddNonstandardSegment(System.String,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:NHapi.Base.Parser.UnexpectedSegmentBehaviour.ThrowHl7Exception">
            <summary>
            Throw an <see cref="T:NHapi.Base.HL7Exception"/>
            </summary>
        </member>
        <member name="T:NHapi.Base.Parser.XMLParser">
            <summary>
            Parses and encodes HL7 messages in XML form, according to HL7's normative XML encoding
            specification.  This is an abstract class that handles datatype and segment parsing/encoding,
            but not the parsing/encoding of entire messages.  To use the XML parser, you should create a
            subclass for a certain message structure.  This subclass must be able to identify the Segment
            objects that correspond to various Segment nodes in an XML document, and call the methods. <code>
            parse(Segment segment, ElementNode segmentNode)</code> and. <code>encode(Segment segment, ElementNode segmentNode)
            </code> as appropriate.  XMLParser uses the Xerces parser, which must be installed in your class path.
            </summary>
            <author>Bryan Tripp, Shawn Bellina.</author>
        </member>
        <member name="P:NHapi.Base.Parser.XMLParser.DefaultEncoding">
            <summary>
            Gets the preferred encoding of this Parser.
            </summary>
        </member>
        <member name="P:NHapi.Base.Parser.XMLParser.KeepAsOriginalNodes">
            <summary>
            <para>
            The nodes whose names match these strings will be kept as original,
            meaning that no white space trimming will occur on them.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Main(System.String[])">
            <summary>Test harness. </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.GetEncoding(System.String)">
            <summary>
            Returns a String representing the encoding of the given message, if
            the encoding is recognized.  For example if the given message appears
            to be encoded using HL7 2.x XML rules then "XML" would be returned.
            If the encoding is not recognized then null is returned.  That this
            method returns a specific encoding does not guarantee that the
            message is correctly encoded (e.g. well formed XML) - just that
            it is not encoded using any other encoding than the one returned.
            Returns null if the encoding is not recognized.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParseDocument(System.Xml.XmlDocument,System.String)">
            <summary>
            <para>Creates and populates a Message object from an XML Document that contains an XML-encoded HL7 message.</para>
            <para>
            The easiest way to implement this method for a particular message structure is as follows:
            <list type="number">
            <item>Create an instance of the Message type you are going to handle with your subclass of
            <see cref="T:NHapi.Base.Parser.XMLParser" /></item>
            <item>Go through the given <see cref="T:System.Xml.XmlDocument"/> and find the <see cref="T:System.Xml.XmlElement">XmlElements</see>
            that represent the top level of each message segment.</item>
            <item>For each of these segments, call <see cref="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/>,
            providing the appropriate <see cref="T:NHapi.Base.Model.ISegment" /> from your <see cref="T:NHapi.Base.Model.IMessage"/> object, and the
            corresponding <see cref="T:System.Xml.XmlElement"/>.</item>
            </list>
            At the end of this process, your <see cref="T:NHapi.Base.Model.IMessage"/> object should be populated with data from the
            <see cref="T:System.Xml.XmlDocument"/>.
            </para>
            </summary>
            <param name="xmlMessage">Xml encoded HL7 parsed into <see cref="T:System.Xml.XmlDocument"/>.</param>
            <param name="version">The name of the HL7 version to which the message belongs (eg "2.5").</param>
            <returns>A parsed HL7 message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the message is not correctly formatted.</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">
            If the message encoded is not supported by this parser.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParseDocument(System.Xml.XmlDocument,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            <para>Creates and populates a Message object from an XML Document that contains an XML-encoded HL7 message.</para>
            <para>
            The easiest way to implement this method for a particular message structure is as follows:
            <list type="number">
            <item>Create an instance of the Message type you are going to handle with your subclass of
            <see cref="T:NHapi.Base.Parser.XMLParser" /></item>
            <item>Go through the given <see cref="T:System.Xml.XmlDocument"/> and find the <see cref="T:System.Xml.XmlElement">XmlElements</see>
            that represent the top level of each message segment.</item>
            <item>For each of these segments, call <see cref="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/>,
            providing the appropriate <see cref="T:NHapi.Base.Model.ISegment" /> from your <see cref="T:NHapi.Base.Model.IMessage"/> object, and the
            corresponding <see cref="T:System.Xml.XmlElement"/>.</item>
            </list>
            At the end of this process, your <see cref="T:NHapi.Base.Model.IMessage"/> object should be populated with data from the
            <see cref="T:System.Xml.XmlDocument"/>.
            </para>
            </summary>
            <param name="xmlMessage">Xml encoded HL7 parsed into <see cref="T:System.Xml.XmlDocument"/>.</param>
            <param name="version">The name of the HL7 version to which the message belongs (eg "2.5").</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <returns>A parsed HL7 message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If the message is not correctly formatted.</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">
            If the message encoded is not supported by this parser.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.EncodeDocument(NHapi.Base.Model.IMessage)">
            <summary>
            <para>Creates an <see cref="T:System.Xml.XmlDocument"/> that corresponds to the given <see cref="T:NHapi.Base.Model.IMessage"/> object.</para>
            <para>If you are implementing this method, you should create an <see cref="T:System.Xml.XmlDocument"/>, and insert
            <see cref="T:System.Xml.XmlElement">XmlElements</see> into it that correspond to the <see cref="T:NHapi.Base.Model.IGroup">IGroups</see> and
            <see cref="T:NHapi.Base.Model.ISegment">ISegments</see> that belong to the <see cref="T:NHapi.Base.Model.IMessage"/> type that your subclass
            of <see cref="T:NHapi.Base.Parser.XMLParser"/> supports. Then, for each segment in the message, call the method
            <see cref="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/> using the <see cref="T:System.Xml.XmlElement"/> for
            that segment and the corresponding <see cref="T:NHapi.Base.Model.ISegment" /> object from the given <see cref="T:NHapi.Base.Model.IMessage"/>.</para>
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IMessage"/> object from which to construct an encoded message string.</param>
            <returns>An <see cref="T:System.Xml.XmlDocument"/> representation of the HL7 message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">When unable to create/populate the <see cref="T:System.Xml.XmlDocument"/>.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.EncodeDocument(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary>
            <para>Creates an <see cref="T:System.Xml.XmlDocument"/> that corresponds to the given <see cref="T:NHapi.Base.Model.IMessage"/> object.</para>
            <para>If you are implementing this method, you should create an <see cref="T:System.Xml.XmlDocument"/>, and insert
            <see cref="T:System.Xml.XmlElement">XmlElements</see> into it that correspond to the <see cref="T:NHapi.Base.Model.IGroup">IGroups</see> and
            <see cref="T:NHapi.Base.Model.ISegment">ISegments</see> that belong to the <see cref="T:NHapi.Base.Model.IMessage"/> type that your subclass
            of <see cref="T:NHapi.Base.Parser.XMLParser"/> supports. Then, for each segment in the message, call the method
            <see cref="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/> using the <see cref="T:System.Xml.XmlElement"/> for
            that segment and the corresponding <see cref="T:NHapi.Base.Model.ISegment" /> object from the given <see cref="T:NHapi.Base.Model.IMessage"/>.</para>
            </summary>
            <param name="source">An <see cref="T:NHapi.Base.Model.IMessage"/> object from which to construct an encoded message string.</param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns>An <see cref="T:System.Xml.XmlDocument"/> representation of the HL7 message.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">When unable to create/populate the <see cref="T:System.Xml.XmlDocument"/>.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Parse(NHapi.Base.Model.ISegment,System.Xml.XmlElement)">
            <summary>
            Populates the given <see cref="T:NHapi.Base.Model.ISegment"/> object with data from the given <see cref="T:System.Xml.XmlElement"/>.
            </summary>
            <param name="segmentObject">The <see cref="T:NHapi.Base.Model.ISegment"/> to parse into.</param>
            <param name="segmentElement">The <see cref="T:System.Xml.XmlElement"/> to be parse.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the <see cref="T:System.Xml.XmlElement"/> does not have the correct name and structure for the given
            <see cref="T:NHapi.Base.Model.ISegment"/>, or if there is an error while setting individual field values.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Parse(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:NHapi.Base.Model.ISegment"/> object with data from the given <see cref="T:System.Xml.XmlElement"/>.
            </summary>
            <param name="segmentObject">The <see cref="T:NHapi.Base.Model.ISegment"/> to parse into.</param>
            <param name="segmentElement">The <see cref="T:System.Xml.XmlElement"/> to be parse.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If the <see cref="T:System.Xml.XmlElement"/> does not have the correct name and structure for the given
            <see cref="T:NHapi.Base.Model.ISegment"/>, or if there is an error while setting individual field values.
            </exception>
            <exception cref="T:NHapi.Base.HL7Exception">
            If any of the <see cref="P:System.Xml.XmlNode.ChildNodes"/> of <paramref name="segmentElement"/> have an invalid namespace.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement)">
            <summary>
            Populates the given <see cref="T:System.Xml.XmlElement"/> with data from the given <see cref="T:NHapi.Base.Model.ISegment"/>, by inserting
            <see cref="T:System.Xml.XmlElement">XmlElements</see> corresponding to the <see cref="T:NHapi.Base.Model.ISegment">Segment's</see> fields,
            their components, etc.
            </summary>
            <param name="segmentObject">The <see cref="T:NHapi.Base.Model.ISegment"/> to be encoded.</param>
            <param name="segmentElement">The <see cref="T:System.Xml.XmlElement"/> to encode into.</param>
            <returns><see langword="true"/> if there is at least one data value in the <see cref="T:NHapi.Base.Model.ISegment"/>.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If an error occurred while encoding.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.ISegment,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:System.Xml.XmlElement"/> with data from the given <see cref="T:NHapi.Base.Model.ISegment"/>, by inserting
            <see cref="T:System.Xml.XmlElement">XmlElements</see> corresponding to the <see cref="T:NHapi.Base.Model.ISegment">Segment's</see> fields,
            their components, etc.
            </summary>
            <param name="segmentObject">The <see cref="T:NHapi.Base.Model.ISegment"/> to be encoded.</param>
            <param name="segmentElement">The <see cref="T:System.Xml.XmlElement"/> to encode into.</param>
            <param name="parserOptions">Contains configuration that will be applied when encoding.</param>
            <returns><see langword="true"/> if there is at least one data value in the <see cref="T:NHapi.Base.Model.ISegment"/>.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">If an error occurred while encoding.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Parse(NHapi.Base.Model.IType,System.Xml.XmlElement)">
            <summary>
            Populates the given <see cref="T:NHapi.Base.Model.IType"/> object with data from the given <see cref="T:System.Xml.XmlElement"/>.
            </summary>
            <param name="datatypeObject">The <see cref="T:NHapi.Base.Model.IType"/> to parse into.</param>
            <param name="datatypeElement">The <see cref="T:System.Xml.XmlElement"/> to be parsed.</param>
            <exception cref="T:NHapi.Base.DataTypeException">if the data did not match the expected type rules.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Parse(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:NHapi.Base.Model.IType"/> object with data from the given <see cref="T:System.Xml.XmlElement"/>.
            </summary>
            <param name="datatypeObject">The <see cref="T:NHapi.Base.Model.IType"/> to parse into.</param>
            <param name="datatypeElement">The <see cref="T:System.Xml.XmlElement"/> to be parsed.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.DataTypeException">if the data did not match the expected type rules.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.GetCriticalResponseData(System.String)">
            <summary> <para>Returns a minimal amount of data from a message string, including only the
            data needed to send a response to the remote system.  This includes the
            following fields:
            <list type="bullet">
            <item><description>field separator</description></item>
            <item><description>encoding characters</description></item>
            <item><description>processing ID</description></item>
            <item><description>message control ID</description></item>
            </list>
            This method is intended for use when there is an error parsing a message,
            (so the Message object is unavailable) but an error message must be sent
            back to the remote system including some of the information in the inbound
            message.  This method parses only that required information, hopefully
            avoiding the condition that caused the original error.</para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.GetAckID(System.String)">
            <summary>
            For response messages, returns the value of MSA-2 (the message ID of the message
            sent by the sending system). This value may be needed prior to main message parsing,
            so that (particularly in a multi-threaded scenario) the message can be routed to
            the thread that sent the request. We need this information first so that any
            parse exceptions are thrown to the correct thread. Implementers of Parsers should
            take care to make the implementation of this method very fast and robust.
            Returns null if MSA-2 can not be found (e.g. if the message is not a
            response message). Trims whitespace from around the MSA-2 field.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.GetVersion(System.String,NHapi.Base.Parser.ParserOptions)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.KeepAsOriginal(System.Xml.XmlNode)">
            <summary>
            Checks if a node content should be kept as original (ie.: whitespaces won't be removed).
            </summary>
            <param name="node">The target node.</param>
            <returns>
            <see langword="true"/> if whitespaces should not be removed from node content; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.KeepAsOriginal(System.Xml.XmlNode,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Checks if a node content should be kept as original (ie.: whitespaces won't be removed).
            </summary>
            <param name="node">The target node.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <returns>
            <see langword="true"/> if whitespaces should not be removed from node content; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.AssertNamespaceUri(System.String)">
            <summary>
            Validates the namespace.
            </summary>
            <param name="namespace">Namespace to assert.</param>
            <exception cref="T:NHapi.Base.HL7Exception">If provided namespace is not valid.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.RemoveWhitespace(System.String)">
            <summary>
            Removes all unnecessary whitespace from the given String (intended to be used with Primitive values).
            This includes leading and trailing whitespace, and repeated space characters. Carriage returns,
            line feeds, and tabs are replaced with spaces.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.DoParse(System.String,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses a message string and returns the corresponding Message
            object. This method checks that the given message string is XML encoded, creates an
            XML Document object (using Xerces) from the given String, and calls the abstract
            method <see cref="M:NHapi.Base.Parser.XMLParser.ParseDocument(System.Xml.XmlDocument,System.String)"/>.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.DoEncode(NHapi.Base.Model.IMessage,System.String,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a Message object into an HL7 message string using the given encoding.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
            <exception cref="T:NHapi.Base.Parser.EncodingNotSupportedException">Thrown if the requested encoding is not supported by this parser.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.DoEncode(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Formats a Message object into an HL7 message string using this parser's
            default encoding (XML encoding). This method calls the abstract method.
            <see cref="M:NHapi.Base.Parser.XMLParser.EncodeDocument(NHapi.Base.Model.IMessage,NHapi.Base.Parser.ParserOptions)"/> in order to obtain <see cref="T:System.Xml.XmlDocument"/> object
            representation of the Message, then serializes it to a String.
            </summary>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the data fields in the message do not permit encoding (e.g. required fields are null).</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParseLeaf(System.String,System.String,System.Int32)">
            <summary>
            <para>Attempts to retrieve the value of a leaf tag without using DOM or SAX.</para>
            <para>This method searches the given message string for the given tag name, and returns
            everything after the given tag and before the start of the next tag.</para>
            <para>Whitespace is stripped.</para>
            </summary>
            <remarks>
            This is intended only for lead nodes, as the value is considered to
            end at the start of the next tag, regardless of whether it is the matching end
            tag or some other nested tag.
            </remarks>
            <param name="message">a string message in XML form.</param>
            <param name="tagName">the name of the XML tag, e.g. "MSA.2".</param>
            <param name="startAt">the character location at which to start searching.</param>
            <exception cref="T:NHapi.Base.HL7Exception">Thrown if the tag can not be found.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.MakeElementName(NHapi.Base.Model.ISegment,System.Int32)">
            <summary>
            Returns the expected XML element name for the given child of the given Segment.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.MakeElementName(NHapi.Base.Model.IComposite,System.Int32)">
            <summary>
            Returns the expected XML element name for the given child of the given Composite.
            </summary>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:System.Xml.XmlElement"/> with data from the given <see cref="T:NHapi.Base.Model.IType"/>, by inserting
            XmlElements corresponding to the Type's components and values.
            </summary>
            <returns>
            <see langword="true" /> if the given type contains a value (i.e. for Primitives, if
            <see cref="P:NHapi.Base.Model.IPrimitive.Value"/> doesn't return null, and for Composites, if at least one underlying
            Primitive doesn't return null).
            </returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.EncodeVaries(NHapi.Base.Model.Varies,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Encodes a Varies type by extracting it's data field and encoding that.
            </summary>
            <returns><see langword="true" /> if the data field (or one of its components) contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.EncodePrimitive(NHapi.Base.Model.IPrimitive,System.Xml.XmlElement)">
            <summary>
            Encodes a Primitive in XML by adding it's value as a child of the given Element.
            </summary>
            <returns><see langword="true" /> if the given Primitive contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.EncodeComposite(NHapi.Base.Model.IComposite,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Encodes a Composite in XML by looping through it's components, creating new
            children for each of them (with the appropriate names) and populating them by
            calling <see cref="M:NHapi.Base.Parser.XMLParser.Encode(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/> using these children.
            </summary>
            <returns><see langword="true" /> if at least one component contains a value.</returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.HasChildElement(System.Xml.XmlElement)">
            <summary>
            Returns <see langword="true"/> if the <paramref name="element"/> provided has any children which are
            are also of type <see cref="F:System.Xml.XmlNodeType.Element"/>.
            </summary>
            <param name="element">Element to test.</param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParseVaries(NHapi.Base.Model.Varies,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Parses an <see cref="T:System.Xml.XmlElement"/> into a <see cref="T:NHapi.Base.Model.Varies"/> by determining whether the element is
            <see cref="T:NHapi.Base.Model.IPrimitive"/> or <see cref="T:NHapi.Base.Model.IComposite"/>, assigning the <see cref="P:NHapi.Base.Model.Varies.Data">Varies.Data</see>
            with a new <see cref="T:NHapi.Base.Model.GenericPrimitive"/> or <see cref="T:NHapi.Base.Model.GenericComposite"/> as appropriate, and then
            calling parse again with this newly assigned <see cref="P:NHapi.Base.Model.Varies.Data">Varies.Data</see>.
            </summary>
            <param name="datatypeObject">The <see cref="T:NHapi.Base.Model.Varies"/> to parse into.</param>
            <param name="datatypeElement">The <see cref="T:System.Xml.XmlElement"/> to be parsed.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.DataTypeException">if the data did not match the expected type rules.</exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParsePrimitive(NHapi.Base.Model.IPrimitive,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the given <see cref="T:NHapi.Base.Model.IPrimitive"/> object with data from the given <see cref="T:System.Xml.XmlElement"/>.
            </summary>
            <param name="datatypeObject">The <see cref="T:NHapi.Base.Model.IPrimitive"/> to parse into.</param>
            <param name="datatypeElement">The <see cref="T:System.Xml.XmlElement"/> to be parsed.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If any of the <see cref="P:System.Xml.XmlNode.ChildNodes">XmlElement.ChildNodes</see> of type
            <see cref="F:System.Xml.XmlNodeType.Element"/> which should be escaped from <paramref name="datatypeElement"/>
            have an invalid namespace.
            </exception>
        </member>
        <member name="M:NHapi.Base.Parser.XMLParser.ParseComposite(NHapi.Base.Model.IComposite,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)">
            <summary>
            Populates the provided <see cref="T:NHapi.Base.Model.IComposite"/> by looping through it's <see cref="P:NHapi.Base.Model.IComposite.Components"/>, finding corresponding
            <see cref="T:System.Xml.XmlElement">XmlElements</see> among the children of the given <see cref="T:System.Xml.XmlElement"/>, and
            calling <see cref="M:NHapi.Base.Parser.XMLParser.Parse(NHapi.Base.Model.IType,System.Xml.XmlElement,NHapi.Base.Parser.ParserOptions)"/> for each.
            </summary>
            <param name="datatypeObject">The <see cref="T:NHapi.Base.Model.IComposite"/> to parse into.</param>
            <param name="datatypeElement">The <see cref="T:System.Xml.XmlElement"/> to be parsed.</param>
            <param name="parserOptions">Contains configuration that will be applied when parsing.</param>
            <exception cref="T:NHapi.Base.HL7Exception">
            If any of the <see cref="P:System.Xml.XmlNode.ChildNodes">XmlElement.ChildNodes</see> of type
            <see cref="F:System.Xml.XmlNodeType.Element"/> which should be escaped from <paramref name="datatypeElement"/>
            have an invalid namespace.
            </exception>
        </member>
        <member name="T:NHapi.Base.PreParser.DatumPath">
            <summary>
            <para>
            An object of this class represents a variable-size path for identifying
            the location of a datum within an HL7 message, which we can use for
            maintaining parser state and for generating a suitable string key (in the
            <c>ZYX[a]-b[c]-d-e</c> style) for a piece of data in the message (see <see cref="M:NHapi.Base.PreParser.DatumPath.ToString" />).
            </para>
            <para>
            The elements are:
            segmentID / segmentRepIdx / fieldIdx / fieldRepIdx / compIdx / subcompIdx
            ("rep" means "repetition").
            </para>
            <para>
            segmentID is a <see cref="T:System.String"/>, the rest are <see cref="T:System.Int32"/>.
            </para>
            <para>
            It is variable-size path-style in that if it has a size of 1, the one element
            will be the segmentID; if it has a size of two, element 0 will be the segmentID
            and element 1 will be the segmentRepIdx, etc.  This class can't represent a
            fieldIdx without having segmentID / segmentRepIdx, etc. etc.
            </para>
            <para>
            Possible sizes: 0 to 6 inclusive.
            </para>
            <para>
            As <see cref="M:NHapi.Base.PreParser.DatumPath.ToString" /> simply converts this' integer values to strings <c>(1 => "1")</c>, and
            since for some reason the <c>ZYX[a]-b[c]-d-e</c> style counts b, d, e starting from 1
            and a, c from 0 -- it is intended that one store the numeric values in this
            class starting from 1 for fieldIdx (element 2), compIdx (4) and subcompIdx
            (5), and from 0 for segmentRepIdx (1) and fieldRepIdx (3).
            </para>
            <para>
            Default values provided by <see cref="M:NHapi.Base.PreParser.DatumPath.ReSize(System.Int32)" /> and by <see cref="M:NHapi.Base.PreParser.DatumPath.ToString" /> do this.
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:NHapi.Base.PreParser.DatumPath"/> class.
            </summary>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.#ctor(NHapi.Base.PreParser.DatumPath)">
            <summary>
            Creates a new instance of the <see cref="T:NHapi.Base.PreParser.DatumPath"/> class from the values of another instance.
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:NHapi.Base.PreParser.DatumPath.Size">
            <summary>
            Gets the number of elements in the path.
            </summary>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Add(System.Int32)">
            <summary>
            <para>
            Grows <see cref="T:NHapi.Base.PreParser.DatumPath"/> by 1, inserting <paramref name="newValue"/> at the end.
            </para>
            <para>
            <paramref name="newValue" /> must be a <see cref="T:System.String"/> or an <see cref="T:System.Int32"/>
            depending on the index where it will be inserted, as noted at <see cref="M:NHapi.Base.PreParser.DatumPath.Set(System.Int32,System.Nullable{System.Int32})"/>.
            </para>
            <para>
            If being inserted at index 0 then the type of <paramref name="newValue"/> must be a <see cref="T:System.String"/>
            otherwise it must be an <see cref="T:System.Int32" />.
            </para>
            <example>
            This method can be chained:
            <code>
            path.Add("ZYX").Add(1).Add(2);
            </code>
            </example>
            </summary>
            <param name="newValue"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <see cref="P:NHapi.Base.PreParser.DatumPath.Size"/> is already equal to 6.</exception>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:NHapi.Base.PreParser.DatumPath.Size"/> is less then 1.</exception>
            <returns>this.</returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Add(System.String)">
            <summary>
            <para>
            Grows <see cref="T:NHapi.Base.PreParser.DatumPath"/> by 1, inserting <paramref name="newValue"/> at the end.
            </para>
            <para>
            <paramref name="newValue" /> must be a <see cref="T:System.String"/> or an <see cref="T:System.Int32"/>
            depending on the index where it will be inserted, as noted at <see cref="M:NHapi.Base.PreParser.DatumPath.Set(System.Int32,System.String)"/>.
            </para>
            <para>
            If being inserted at index 0 then the type of <paramref name="newValue"/> must be a <see cref="T:System.String"/>
            otherwise it must be an <see cref="T:System.Int32" />.
            </para>
            <example>
            This method can be chained:
            <code>
            path.Add("ZYX").Add(1).Add(2);
            </code>
            </example>
            </summary>
            <param name="newValue"></param>
            <returns>this.</returns>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:NHapi.Base.PreParser.DatumPath.Size"/> is not equal to 0.</exception>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Get(System.Int32)">
            <summary>
            Gets an element of the path at the specified index.
            </summary>
            <remarks>
            <para>
            The type of the value returned is determined by the index.
            </para>
            <para>
            If the index equal to 0 then the value returned is a <see cref="T:System.String"/>.
            </para>
            <para>
            If the index is greater than 1 then the value returned is a <see cref="T:System.Int32"/>.
            </para>
            </remarks>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.IndexOutOfRangeException">
            If the index specified is less than 0 or greater than <see cref="P:NHapi.Base.PreParser.DatumPath.Size"/>.
            </exception>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Set(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Sets an element of the path, at the specified index.
            </summary>
            <param name="index">Location to add element.</param>
            <param name="newValue">Value to add.</param>
            <exception cref="T:System.ArgumentException">When attempting to set an int value to index position 0.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newValue"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="index" /> is less than 0 or greater than or equal to <see cref="P:NHapi.Base.PreParser.DatumPath.Size"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">if <paramref name="index" /> is greater than 6.</exception>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Set(System.Int32,System.String)">
            <summary>
            Sets an element of the path, at the specified index.
            </summary>
            <param name="index">Location to add element.</param>
            <param name="newValue">Value to add.</param>
            <exception cref="T:System.ArgumentException">When attempting to set a string value to index position other than 0.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="newValue"/> is null.</exception>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.ReSize(System.Int32)">
            <summary>
            <para>
            Resize the <see cref="T:NHapi.Base.PreParser.DatumPath"/>.
            </para>
            <para>
            If <paramref name="newSize"/> is greater than the current
            size, then the new elements are set to default values.
            </para>
            <para>
            Then we put default values into the new elements: i.e. <see cref="F:System.String.Empty"/>
            into the string element, 1 into the elements 2, 4, and 5, and 0 into elements 1 and 3.
            </para>
            <para>
            If <paramref name="newSize"/> is less than the current size, then the last elements are removed.
            </para>
            </summary>
            <param name="newSize">The desired size for the path.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="newSize" /> is greater than 6.</exception>
            <returns>this.</returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Clear">
            <summary>
            Resets the <see cref="T:NHapi.Base.PreParser.DatumPath"/> to the default state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Clone">
            <summary>
            Clones the <see cref="T:NHapi.Base.PreParser.DatumPath"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.Copy(NHapi.Base.PreParser.DatumPath)">
            <summary>
            Copy the path elements from the specified <see cref="T:NHapi.Base.PreParser.DatumPath"/>.
            </summary>
            <param name="other">The instance of <see cref="T:NHapi.Base.PreParser.DatumPath"/> to copy path elements from.</param>
            <exception cref="T:System.InvalidOperationException">
            If the values of the <paramref name="other" /> are not of the expected types (either <see cref="T:System.String"/> or <see cref="T:System.Int32"/>).
            </exception>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPath.ToString">
            <summary>
            Returns a string that represents the current <see cref="T:NHapi.Base.PreParser.DatumPath"/>.
            </summary>
            <remarks>
            <para>
            Outputs the path (from segmentID onward) in the <c>ZYX[a]-b[c]-d-e</c>
            style (TODO: give it a name), suitable for a key in a map of message datum paths to values.
            </para>
            <para>
            Integer values are converted to strings directly <c>(1 => "1")</c> so when you
            constructed this you should have started counting from 1 for everything but
            the "repeat" fields, if you truly want the <c>ZYX[a]-b[c]-d-e</c> style.
            </para>
            <para>
            If <see cref="M:NHapi.Base.PreParser.DatumPath.ToString"/> is called when this has a size in [1, 6) (=> missing numeric
            elements), then we act as though the elements in [size(), 6) are 0 or 1 as
            appropriate for each element.  We don't provide a default for the element 0.
            </para>
            <example>
            <code>
            new DatumPath().Add("ZYX").Add(2).Add(6).ToString();
            </code>
            Would yield "ZYX[2]-6[0]-1-1"
            </example>
            </remarks>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPathExtensions.NumbersLessThan(NHapi.Base.PreParser.DatumPath,NHapi.Base.PreParser.DatumPath)">
            <summary>
            <para>
            Compares the numeric parts of <paramref name="input"/> and <paramref name="other"/>. "string style", start from
            the left: if this[1] &lt; other[1], then return true, if this[1] &gt; other[1] then
            return false, else repeat with [2] ... if we compare all elements, then return
            false (they're the same.)
            </para>
            <para>
            What are actually compared are copies of this and other that have been grown
            to a capacity of 6 (default values in effect), so they'll have the same size.
            </para>
            <para>
            This is just a little thing that gets used in the class XML. Look there for
            a justification of it's existence.
            </para>
            e.g.
            <example>
            <code>
            [1, 1, 1, 1] &lt; [1, 1, 1, 2]
            [1, 2, 1, 1] &lt; [1, 2, 1, 2]
            [1, 1, 5, 5] &lt; [1, 2]
            [1, 1] &lt; [1, 1, 5, 5]
            </code>
            </example>
            </summary>
            <param name="input">Current instance of <see cref="T:NHapi.Base.PreParser.DatumPath"/>.</param>
            <param name="other">Instance of <see cref="T:NHapi.Base.PreParser.DatumPath"/> to compare to.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="input"/> is null.</exception>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.PreParser.DatumPathExtensions.StartsWith(NHapi.Base.PreParser.DatumPath,NHapi.Base.PreParser.DatumPath)">
            <summary>
            Determines whether this <see cref="T:NHapi.Base.PreParser.DatumPath"/> instance starts with the same
            path elements as the specified <see cref="T:NHapi.Base.PreParser.DatumPath"/>.
            <example>
            <code>
            var result = path.StartsWith(otherPath);
            </code>
            </example>
            </summary>
            <param name="input">The <see cref="T:NHapi.Base.PreParser.DatumPath"/> instance.</param>
            <param name="prefix">The <see cref="T:NHapi.Base.PreParser.DatumPath"/> to compare.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="input"/> is null.</exception>
            <returns>
            <see langword="true" /> if <paramref name="input"/> starts with the same
            path elements as <paramref name="prefix"/>; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="F:NHapi.Base.PreParser.Er7.SEGMENT_SEPARATORS">
            <summary>
            <see cref="T:System.Char"/> that delimit segments.
            for use with <see cref="T:NHapi.Base.SupportClass.Tokenizer"/>.
            </summary>
            <remarks>
            We are forgiving: HL7 2.3.1 section 2.7 says that carriage return <c>'\r'</c> is
            the only segment delimiter.  TODO: check other versions.
            </remarks>
        </member>
        <member name="M:NHapi.Base.PreParser.Er7.TryParseMessage(System.String,System.Collections.Generic.IList{NHapi.Base.PreParser.DatumPath},System.Collections.Generic.IDictionary{System.String,System.String}@)">
            <summary>
            Parse message and return data found with provided <see cref="T:NHapi.Base.PreParser.DatumPath">DatumPaths</see>.
            </summary>
            <param name="message">Er7 encoded hl7 v2 message.</param>
            <param name="messageMask">The location/path to retrieve values from.</param>
            <param name="results">The values found in message.</param>
            <returns>
            <see langword="true"/> if parsed okay i.e. looks like Er7 encoded HL7.
            <para>
            We just barely check against HL7 structure, and ignore any elements / text that is unexpected
            (that is, impossible in any HL7 message: independent of any message / segment definitions).
            </para>
            </returns>
        </member>
        <member name="T:NHapi.Base.PreParser.PreParser">
            <summary>
            Extracts specified fields from unparsed messages.
            <example>
            <code>
            var message = null; //... your ER7 or XML message string goes here
            var fieldSpecs = new string[] { "MSH-9-1", "MSH-9-2", "MSH-12" };
            var fields = PreParser.GetFields(message, fieldSpecs);
            </code>
            </example>
            <remarks>This class is a facade for the <see cref="T:NHapi.Base.PreParser.Er7"/> and <see cref="T:NHapi.Base.PreParser.Xml"/> classes.</remarks>
            </summary>
        </member>
        <member name="M:NHapi.Base.PreParser.PreParser.GetFields(System.String,System.String[])">
            <summary>
            Extracts selected fields from a message.
            </summary>
            <param name="message">An unparsed message from which to get fields.</param>
            <param name="pathSpecs">
            Terser-like paths to fields in the message.
            See documentation for <see cref="T:NHapi.Base.Util.Terser"/>.
            These paths are identical except that they start with the segment name (search flags and group
            names are to be omitted as they are not relevant with unparsed ER7 messages).
            </param>
            <returns>Field values corresponding to the given paths.</returns>
            <exception cref="T:NHapi.Base.HL7Exception">When detecting message encoding fails or when parsing the message fails.</exception>
        </member>
        <member name="M:NHapi.Base.PreParser.Xml.TryParseMessage(System.String,System.Collections.Generic.IEnumerable{NHapi.Base.PreParser.DatumPath},System.Collections.Generic.IDictionary{System.String,System.String}@)">
            <summary>
            Parse message and return data found with provided <see cref="T:NHapi.Base.PreParser.DatumPath">DatumPaths</see>.
            </summary>
            <remarks>
            <para>
            <paramref name="message"/> should be an XML document with one top level element, that being the
            message i.e. <![CDATA[<ACK>]]> or whatever.
            </para>
            <para>
            We are only expecting one message / xml document to be in the<paramref name="message"/>.
            </para>
            <para>
            The <paramref name="message"/> data (located via passed in <paramref name="messageMasks"/>) will be added to
            <paramref name="results"/> as key / value pairs with the key being
            <see cref="M:NHapi.Base.PreParser.DatumPath.ToString">DatumPath.ToString()</see> of the appropriate <see cref="T:NHapi.Base.PreParser.DatumPath" />
            for the location where the data is found (i.e. in the <c>ZYX[a]-b[c]-d-e</c> style), and the value
            being that of the corresponding text.
            </para>
            <para>So, after calling <see cref="M:NHapi.Base.PreParser.Xml.TryParseMessage(System.String,System.Collections.Generic.IEnumerable{NHapi.Base.PreParser.DatumPath},System.Collections.Generic.IDictionary{System.String,System.String}@)"/> successfully, if you wanted to retrieve the
            message data from <paramref name="results"/> you might call something like:
            <code>
            var key = new DatumPath().Add("MSH").Add(1).ToString();
            results.TryGetValue(key, out var @value)</code>
            and that would return a String with "|", probably.
            </para>
            <para>
            Note that this package facilitates the extraction of message data in a way
            independent of message version (i.e. components and whatever getting added):
            </para>
            <para>
            With a <paramref name="message" /> of <![CDATA[<FOO><ZYX><ZYX.42>fieldy-field-field</ZYX.42></ZYX></FOO>]]>,
            <c>ZYX[0]-1[0]-1-1</c> will be the key that ends up in <paramref name="results"/> (see notes at
            <see cref="M:NHapi.Base.PreParser.DatumPath.ToString">DatumPath.ToString()</see>).
            </para>
            <para>
            So if you, coding for a future version of the FOO message but receiving an old-version message data,
            tried:
            <code>
            var key = new DatumPath().Add("ZYX").Add(0).Add(42).Add(0).Add(1).ToString();
            results.TryGetValue(key, out var @value)</code> with the message above (that is, trying to extract a
            repetition and component that aren't there), you would get <c>ZYX[0]-42[0]-1-1</c> mapping to
            "fieldy-field-field" in the resulting <paramref name="results"/>.
            </para>
            <para>
            If the <paramref name="message" /> was <![CDATA[<FOO><ZYX><ZYX.42><ARG.1>component data</ARG.1></ZYX.42></ZYX></FOO>]]>
            and you, coding for an old version of this FOO message but receiving new-version FOO message data,
            tried:
            <code>
            var key = new DatumPath().Add("ZYX").Add(0).Add(42).ToString();
            results.TryGetValue(key, out var @value)</code> you would get <c>ZYX[0]-42[0]-1-1</c> mapping to
            "component data" in the resulting <paramref name="results"/>.
            </para>
            <para>
            <paramref name="messageMasks" /> lets you specify which parts of the message you want dumped to
            <paramref name="results"/>. Passing in null gets you everything. Otherwise, <paramref name="messageMasks" />
            elements should all be <see cref="T:NHapi.Base.PreParser.DatumPath">DatumPaths</see>, and a particular part of the message
            will be added to <paramref name="results"/> only if it's location, as represented by a
            <see cref="T:NHapi.Base.PreParser.DatumPath" />, starts with (as in <see cref="M:NHapi.Base.PreParser.DatumPathExtensions.StartsWith(NHapi.Base.PreParser.DatumPath,NHapi.Base.PreParser.DatumPath)">DatumPathExtensions.StartsWith</see>)
            at least one element of <paramref name="messageMasks" />.
            </para>
            <para>So if one element of <paramref name="messageMasks" /> was a
            <c>new DatumPath().Add("ZYX")</c>, then everything in all <c>ZYX</c> segment would get dumped to
            <paramref name="results"/>. A <c>new DatumPath().Add("ZYX").Add(1)</c> would get only the first
            repetitions of same (if there is one) dumped to <paramref name="results"/>. etc. etc.
            </para>
            <para>
            Note that a <see cref="T:NHapi.Base.PreParser.DatumPath" /> of <see cref="P:NHapi.Base.PreParser.DatumPath.Size" /> == 0 in <paramref name="messageMasks" />
            will get you everything, no matter what the other elements of <paramref name="messageMasks" /> are, because
            all <see cref="T:NHapi.Base.PreParser.DatumPath">DatumPaths</see> starts with the zero-length <see cref="T:NHapi.Base.PreParser.DatumPath" />.
            </para>
            <para>
            Segment group elements (eg. ADT_A01.PROCEDURE) are handled fine, but they aren't addressed in
            <paramref name="messageMasks" /> or in the output in <paramref name="results"/> -- basically any element tags
            at the level immediately inside the message element, and having a name that starts with the
            message element name + '.', is ignored (meaning it's contents are dealt with the same as if the
            start and end tags' just  wasn't there.).
            </para>
            </remarks>
            <param name="message">Xml encoded HL7 v2 message.</param>
            <param name="messageMasks">The location/path to retrieve values from.</param>
            <param name="results">The values found in message.</param>
            <returns>
            <see langword="true"/> if parsed okay i.e. xml was well formed.
            <para>
            We just barely check against HL7 structure, and ignore any elements / text that is unexpected
            (that is, impossible in any HL7 message: independent of any message / segment definitions).
            </para>
            </returns>
        </member>
        <member name="T:NHapi.Base.IThreadRunnable">
            <summary>
            This interface should be implemented by any class whose instances are intended
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:NHapi.Base.IThreadRunnable.Run">
            <summary>
            This method has to be implemented in order that starting of the thread causes the object's
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:NHapi.Base.IXmlSaxErrorHandler">
            <summary>
            This interface will manage errors during the parsing of a XML document.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxErrorHandler.error(System.Xml.XmlException)">
            <summary>
            This method manage an error exception occurred during the parsing process.
            </summary>
            <param name="exception">The exception thrown by the parser.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxErrorHandler.fatalError(System.Xml.XmlException)">
            <summary>
            This method manage a fatal error exception occurred during the parsing process.
            </summary>
            <param name="exception">The exception thrown by the parser.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxErrorHandler.warning(System.Xml.XmlException)">
            <summary>
            This method manage a warning exception occurred during the parsing process.
            </summary>
            <param name="exception">The exception thrown by the parser.</param>
        </member>
        <member name="T:NHapi.Base.XmlSourceSupport">
            <summary>
            This class is used to encapsulate a source of Xml code in an single class.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSourceSupport.#ctor">
            <summary>
            Constructs an empty XmlSourceSupport instance.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSourceSupport.#ctor(System.IO.Stream)">
            <summary>
            Constructs a XmlSource instance with the specified source System.IO.Stream.
            </summary>
            <param name="stream">The stream containing the document.</param>
        </member>
        <member name="M:NHapi.Base.XmlSourceSupport.#ctor(System.IO.StreamReader)">
            <summary>
            Constructs a XmlSource instance with the specified source System.IO.StreamReader.
            </summary>
            <param name="reader">The reader containing the document.</param>
        </member>
        <member name="M:NHapi.Base.XmlSourceSupport.#ctor(System.String)">
            <summary>
            Construct a XmlSource instance with the specified source Uri string.
            </summary>
            <param name="source">The source containing the document.</param>
        </member>
        <member name="P:NHapi.Base.XmlSourceSupport.Bytes">
            <summary>
            Represents the source Stream of the XmlSource.
            </summary>
        </member>
        <member name="P:NHapi.Base.XmlSourceSupport.Characters">
            <summary>
            Represents the source StreamReader of the XmlSource.
            </summary>
        </member>
        <member name="P:NHapi.Base.XmlSourceSupport.Uri">
            <summary>
            Represents the source URI of the XmlSource.
            </summary>
        </member>
        <member name="T:NHapi.Base.IXmlSaxEntityResolver">
            <summary>
            Basic interface for resolving entities.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxEntityResolver.resolveEntity(System.String,System.String)">
            <summary>
            Allow the application to resolve external entities.
            </summary>
            <param name="publicId">The public identifier of the external entity being referenced, or null if none was supplied.</param>
            <param name="systemId">The system identifier of the external entity being referenced.</param>
            <returns>A XmlSourceSupport object describing the new input source, or null to request that the parser open a regular URI connection to the system identifier.</returns>
        </member>
        <member name="T:NHapi.Base.IXmlSaxContentHandler">
            <summary>
            This interface will manage the Content events of a XML document.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.characters(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the notification when Characters elements were found.
            </summary>
            <param name="ch">The array with the characters found.</param>
            <param name="start">The index of the first position of the characters found.</param>
            <param name="length">Specify how many characters must be read from the array.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.endDocument">
            <summary>
            This method manage the notification when the end document node were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.endElement(System.String,System.String,System.String)">
            <summary>
            This method manage the notification when the end element node was found.
            </summary>
            <param name="namespaceURI">The namespace URI of the element.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The long (qualified) name of the element.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.endPrefixMapping(System.String)">
            <summary>
            This method manage the event when an area of expecific URI prefix was ended.
            </summary>
            <param name="prefix">The prefix that ends.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.ignorableWhitespace(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the event when a ignorable whitespace node was found.
            </summary>
            <param name="Ch">The array with the ignorable whitespaces.</param>
            <param name="Start">The index in the array with the ignorable whitespace.</param>
            <param name="Length">The length of the whitespaces.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.processingInstruction(System.String,System.String)">
            <summary>
            This method manage the event when a processing instruction was found.
            </summary>
            <param name="target">The processing instruction target.</param>
            <param name="data">The processing instruction data.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.setDocumentLocator(NHapi.Base.IXmlSaxLocator)">
            <summary>
            This method is not supported, it is included for compatibility.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.skippedEntity(System.String)">
            <summary>
            This method manage the event when a skipped entity was found.
            </summary>
            <param name="name">The name of the skipped entity.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.startDocument">
            <summary>
            This method manage the event when a start document node was found.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.startElement(System.String,System.String,System.String,NHapi.Base.SaxAttributesSupport)">
            <summary>
            This method manage the event when a start element node was found.
            </summary>
            <param name="namespaceURI">The namespace uri of the element tag.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The long (qualified) name of the element.</param>
            <param name="atts">The list of attributes of the element.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxContentHandler.startPrefixMapping(System.String,System.String)">
            <summary>
            This methods indicates the start of a prefix area in the XML document.
            </summary>
            <param name="prefix">The prefix of the area.</param>
            <param name="uri">The namespace URI of the prefix area.</param>
        </member>
        <member name="T:NHapi.Base.IXmlSaxLocator">
            <summary>
            This interface is created to emulate the SAX Locator interface behavior.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLocator.getColumnNumber">
            <summary>
            This method return the column number where the current document event ends.
            </summary>
            <returns>The column number where the current document event ends.</returns>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLocator.getLineNumber">
            <summary>
            This method return the line number where the current document event ends.
            </summary>
            <returns>The line number where the current document event ends.</returns>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLocator.getPublicId">
            <summary>
            This method is not supported, it is included for compatibility.
            </summary>
            <returns>The saved public identifier.</returns>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLocator.getSystemId">
            <summary>
            This method is not supported, it is included for compatibility.
            </summary>
            <returns>The saved system identifier.</returns>
        </member>
        <member name="T:NHapi.Base.XmlSaxLocatorImpl">
            <summary>
            This class is created for emulates the SAX LocatorImpl behaviors.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.#ctor">
            <summary>
            This method returns a new instance of 'XmlSaxLocatorImpl'.
            </summary>
            <returns>A new 'XmlSaxLocatorImpl' instance.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.#ctor(NHapi.Base.IXmlSaxLocator)">
            <summary>
            This method returns a new instance of 'XmlSaxLocatorImpl'.
            Create a persistent copy of the current state of a locator.
            </summary>
            <param name="locator">The current state of a locator.</param>
            <returns>A new 'XmlSaxLocatorImpl' instance.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.getPublicId">
            <summary>
            This method is not supported, it is included for compatibility.
            Return the saved public identifier.
            </summary>
            <returns>The saved public identifier.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.getSystemId">
            <summary>
            This method is not supported, it is included for compatibility.
            Return the saved system identifier.
            </summary>
            <returns>The saved system identifier.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.getLineNumber">
            <summary>
            Return the saved line number.
            </summary>
            <returns>The saved line number.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.getColumnNumber">
            <summary>
            Return the saved column number.
            </summary>
            <returns>The saved column number.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.setPublicId(System.String)">
            <summary>
            This method is not supported, it is included for compatibility.
            Set the public identifier for this locator.
            </summary>
            <param name="publicId">The new public identifier.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.setSystemId(System.String)">
            <summary>
            This method is not supported, it is included for compatibility.
            Set the system identifier for this locator.
            </summary>
            <param name="systemId">The new system identifier.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.setLineNumber(System.Int32)">
            <summary>
            Set the line number for this locator.
            </summary>
            <param name="lineNumber">The line number.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxLocatorImpl.setColumnNumber(System.Int32)">
            <summary>
            Set the column number for this locator.
            </summary>
            <param name="columnNumber">The column number.</param>
        </member>
        <member name="T:NHapi.Base.IXmlSaxLexicalHandler">
            <summary>
            This interface will manage the Content events of a XML document.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.comment(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the notification when Characters elements were found.
            </summary>
            <param name="ch">The array with the characters found.</param>
            <param name="start">The index of the first position of the characters found.</param>
            <param name="length">Specify how many characters must be read from the array.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.endCDATA">
            <summary>
            This method manage the notification when the end of a CDATA section were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.endDTD">
            <summary>
            This method manage the notification when the end of DTD declarations were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.endEntity(System.String)">
            <summary>
            This method report the end of an entity.
            </summary>
            <param name="name">The name of the entity that is ending.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.startCDATA">
            <summary>
            This method manage the notification when the start of a CDATA section were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.startDTD(System.String,System.String,System.String)">
            <summary>
            This method manage the notification when the start of DTD declarations were found.
            </summary>
            <param name="name">The name of the DTD entity.</param>
            <param name="publicId">The public identifier.</param>
            <param name="systemId">The system identifier.</param>
        </member>
        <member name="M:NHapi.Base.IXmlSaxLexicalHandler.startEntity(System.String)">
            <summary>
            This method report the start of an entity.
            </summary>
            <param name="name">The name of the entity that is ending.</param>
        </member>
        <member name="T:NHapi.Base.SaxAttributesSupport">
            <summary>
            This class will manage all the parsing operations emulating the SAX parser behavior.
            </summary>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.#ctor">
            <summary>
            Builds a new instance of SaxAttributesSupport.
            </summary>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.#ctor(NHapi.Base.SaxAttributesSupport)">
            <summary>
            Creates a new instance of SaxAttributesSupport from an ArrayList of Att_Instance class.
            </summary>
            <param name="List">An ArraList of Att_Instance class instances.</param>
            <returns>A new instance of SaxAttributesSupport.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.Add(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Adds a new attribute element to the given SaxAttributesSupport instance.
            </summary>
            <param name="Uri">The Uri of the attribute to be added.</param>
            <param name="Lname">The Local name of the attribute to be added.</param>
            <param name="Qname">The Long(qualify) name of the attribute to be added.</param>
            <param name="Type">The type of the attribute to be added.</param>
            <param name="Value">The value of the attribute to be added.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.Clear">
            <summary>
            Clears the list of attributes in the given AttributesSupport instance.
            </summary>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetIndex(System.String)">
            <summary>
            Obtains the index of an attribute of the AttributeSupport from its qualified (long) name.
            </summary>
            <param name="Qname">The qualified name of the attribute to search.</param>
            <returns>An zero-based index of the attribute if it is found, otherwise it returns -1.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetIndex(System.String,System.String)">
            <summary>
            Obtains the index of an attribute of the AttributeSupport from its namespace URI and its local name.
            </summary>
            <param name="Uri">The namespace URI of the attribute to search.</param>
            <param name="Lname">The local name of the attribute to search.</param>
            <returns>An zero-based index of the attribute if it is found, otherwise it returns -1.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetLength">
            <summary>
            Returns the number of attributes saved in the SaxAttributesSupport instance.
            </summary>
            <returns>The number of elements in the given SaxAttributesSupport instance.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetLocalName(System.Int32)">
            <summary>
            Returns the local name of the attribute in the given SaxAttributesSupport instance that indicates the given index.
            </summary>
            <param name="index">The attribute index.</param>
            <returns>The local name of the attribute indicated by the index or null if the index is out of bounds.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetFullName(System.Int32)">
            <summary>
            Returns the qualified name of the attribute in the given SaxAttributesSupport instance that indicates the given index.
            </summary>
            <param name="index">The attribute index.</param>
            <returns>The qualified name of the attribute indicated by the index or null if the index is out of bounds.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetType(System.Int32)">
            <summary>
            Returns the type of the attribute in the given SaxAttributesSupport instance that indicates the given index.
            </summary>
            <param name="index">The attribute index.</param>
            <returns>The type of the attribute indicated by the index or null if the index is out of bounds.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetURI(System.Int32)">
            <summary>
            Returns the namespace URI of the attribute in the given SaxAttributesSupport instance that indicates the given index.
            </summary>
            <param name="index">The attribute index.</param>
            <returns>The namespace URI of the attribute indicated by the index or null if the index is out of bounds.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetValue(System.Int32)">
            <summary>
            Returns the value of the attribute in the given SaxAttributesSupport instance that indicates the given index.
            </summary>
            <param name="index">The attribute index.</param>
            <returns>The value of the attribute indicated by the index or null if the index is out of bounds.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetLocalName(System.Int32,System.String)">
            <summary>
            Modifies the local name of the attribute in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The attribute index.</param>
            <param name="LocalName">The new Local name for the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetFullName(System.Int32,System.String)">
            <summary>
            Modifies the qualified name of the attribute in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The attribute index.</param>
            <param name="FullName">The new qualified name for the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetType(System.Int32,System.String)">
            <summary>
            Modifies the type of the attribute in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The attribute index.</param>
            <param name="Type">The new type for the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetURI(System.Int32,System.String)">
            <summary>
            Modifies the namespace URI of the attribute in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The attribute index.</param>
            <param name="URI">The new namespace URI for the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetValue(System.Int32,System.String)">
            <summary>
            Modifies the value of the attribute in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The attribute index.</param>
            <param name="Value">The new value for the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.RemoveAttribute(System.Int32)">
            <summary>
            This method eliminates the Att_Instance instance at the specified index.
            </summary>
            <param name="index">The index of the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.RemoveAttribute(System.String)">
            <summary>
            This method eliminates the Att_Instance instance in the specified index.
            </summary>
            <param name="indexName">The index name of the attribute.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetAttribute(System.Int32,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Replaces an Att_Instance in the given SaxAttributesSupport instance.
            </summary>
            <param name="index">The index of the attribute.</param>
            <param name="Uri">The namespace URI of the new Att_Instance.</param>
            <param name="Lname">The local name of the new Att_Instance.</param>
            <param name="Qname">The namespace URI of the new Att_Instance.</param>
            <param name="Type">The type of the new Att_Instance.</param>
            <param name="Value">The value of the new Att_Instance.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.SetAttributes(NHapi.Base.SaxAttributesSupport)">
            <summary>
            Replaces all the list of Att_Instance of the given SaxAttributesSupport instance.
            </summary>
            <param name="Source">The source SaxAttributesSupport instance.</param>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetType(System.String)">
            <summary>
            Returns the type of the Attribute that match with the given qualified name.
            </summary>
            <param name="Qname">The qualified name of the attribute to search.</param>
            <returns>The type of the attribute if it exist otherwise returns null.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetType(System.String,System.String)">
            <summary>
            Returns the type of the Attribute that match with the given namespace URI and local name.
            </summary>
            <param name="Uri">The namespace URI of the attribute to search.</param>
            <param name="Lname">The local name of the attribute to search.</param>
            <returns>The type of the attribute if it exist otherwise returns null.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetValue(System.String)">
            <summary>
            Returns the value of the Attribute that match with the given qualified name.
            </summary>
            <param name="Qname">The qualified name of the attribute to search.</param>
            <returns>The value of the attribute if it exist otherwise returns null.</returns>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.GetValue(System.String,System.String)">
            <summary>
            Returns the value of the Attribute that match with the given namespace URI and local name.
            </summary>
            <param name="Uri">The namespace URI of the attribute to search.</param>
            <param name="Lname">The local name of the attribute to search.</param>
            <returns>The value of the attribute if it exist otherwise returns null.</returns>
        </member>
        <member name="T:NHapi.Base.SaxAttributesSupport.Att_Instance">
            <summary>
            This class is created to save the information of each attributes in the SaxAttributesSupport.
            </summary>
        </member>
        <member name="M:NHapi.Base.SaxAttributesSupport.Att_Instance.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This is the constructor of the Att_Instance.
            </summary>
            <param name="Uri">The namespace URI of the attribute.</param>
            <param name="Lname">The local name of the attribute.</param>
            <param name="Qname">The long(Qualify) name of attribute.</param>
            <param name="Type">The type of the attribute.</param>
            <param name="Value">The value of the attribute.</param>
        </member>
        <member name="T:NHapi.Base.ManagerNotRecognizedException">
            <summary>
            This exception is thrown by the XmlSaxDocumentManager in the SetProperty and SetFeature
            methods if a property or method couldn't be found.
            </summary>
        </member>
        <member name="M:NHapi.Base.ManagerNotRecognizedException.#ctor(System.String)">
            <summary>
            Creates a new ManagerNotRecognizedException with the message specified.
            </summary>
            <param name="Message">Error message of the exception.</param>
        </member>
        <member name="T:NHapi.Base.ManagerNotSupportedException">
            <summary>
            This exception is thrown by the XmlSaxDocumentManager in the SetProperty and SetFeature methods
            if a property or method couldn't be supported.
            </summary>
        </member>
        <member name="M:NHapi.Base.ManagerNotSupportedException.#ctor(System.String)">
            <summary>
            Creates a new ManagerNotSupportedException with the message specified.
            </summary>
            <param name="Message">Error message of the exception.</param>
        </member>
        <member name="T:NHapi.Base.XmlSaxDefaultHandler">
            <summary>
            This class provides the base implementation for the management of XML documents parsing.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.characters(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the notification when Characters element were found.
            </summary>
            <param name="ch">The array with the characters founds.</param>
            <param name="start">The index of the first position of the characters found.</param>
            <param name="length">Specify how many characters must be read from the array.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.endDocument">
            <summary>
            This method manage the notification when the end document node were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.endElement(System.String,System.String,System.String)">
            <summary>
            This method manage the notification when the end element node were found.
            </summary>
            <param name="uri">The namespace URI of the element.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The long name (qualify name) of the element.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.endPrefixMapping(System.String)">
            <summary>
            This method manage the event when an area of expecific URI prefix was ended.
            </summary>
            <param name="prefix">The prefix that ends.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.error(System.Xml.XmlException)">
            <summary>
            This method manage when an error exception occurs in the parsing process.
            </summary>
            <param name="e">The exception throws by the parser.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.fatalError(System.Xml.XmlException)">
            <summary>
            This method manage when a fatal error exception occurs in the parsing process.
            </summary>
            <param name="e">The exception Throws by the parser.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.ignorableWhitespace(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the event when a ignorable whitespace node were found.
            </summary>
            <param name="ch">The array with the ignorable whitespaces.</param>
            <param name="start">The index in the array with the ignorable whitespace.</param>
            <param name="length">The length of the whitespaces.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.notationDecl(System.String,System.String,System.String)">
            <summary>
            This method is not supported only is created for compatibility.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.processingInstruction(System.String,System.String)">
            <summary>
            This method manage the event when a processing instruction were found.
            </summary>
            <param name="target">The processing instruction target.</param>
            <param name="data">The processing instruction data.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.resolveEntity(System.String,System.String)">
            <summary>
            Allow the application to resolve external entities.
            </summary>
            <param name="publicId">The public identifier of the external entity being referenced, or null if none was supplied.</param>
            <param name="systemId">The system identifier of the external entity being referenced.</param>
            <returns>A XmlSourceSupport object describing the new input source, or null to request that the parser open a regular URI connection to the system identifier.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.setDocumentLocator(NHapi.Base.IXmlSaxLocator)">
            <summary>
            This method is not supported, is include for compatibility.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.skippedEntity(System.String)">
            <summary>
            This method manage the event when a skipped entity were found.
            </summary>
            <param name="name">The name of the skipped entity.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.startDocument">
            <summary>
            This method manage the event when a start document node were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.startElement(System.String,System.String,System.String,NHapi.Base.SaxAttributesSupport)">
            <summary>
            This method manage the event when a start element node were found.
            </summary>
            <param name="uri">The namespace uri of the element tag.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The Qualify (long) name of the element.</param>
            <param name="attributes">The list of attributes of the element.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.startPrefixMapping(System.String,System.String)">
            <summary>
            This methods indicates the start of a prefix area in the XML document.
            </summary>
            <param name="prefix">The prefix of the area.</param>
            <param name="uri">The namespace uri of the prefix area.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.unparsedEntityDecl(System.String,System.String,System.String,System.String)">
            <summary>
            This method is not supported only is created for compatibility.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxDefaultHandler.warning(System.Xml.XmlException)">
            <summary>
            This method manage when a warning exception occurs in the parsing process.
            </summary>
            <param name="e">The exception Throws by the parser.</param>
        </member>
        <member name="T:NHapi.Base.XmlSaxParserAdapter">
            <summary>
            This class provides the base implementation for the management of XML documents parsing.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.characters(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the notification when Characters element were found.
            </summary>
            <param name="ch">The array with the characters founds.</param>
            <param name="start">The index of the first position of the characters found.</param>
            <param name="length">Specify how many characters must be read from the array.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.endDocument">
            <summary>
            This method manage the notification when the end document node were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.endElement(System.String,System.String,System.String)">
            <summary>
            This method manage the notification when the end element node were found.
            </summary>
            <param name="namespaceURI">The namespace URI of the element.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The long name (qualify name) of the element.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.endPrefixMapping(System.String)">
            <summary>
            This method manage the event when an area of expecific URI prefix was ended.
            </summary>
            <param name="prefix">The prefix that ends.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.ignorableWhitespace(System.Char[],System.Int32,System.Int32)">
            <summary>
            This method manage the event when a ignorable whitespace node were found.
            </summary>
            <param name="ch">The array with the ignorable whitespaces.</param>
            <param name="start">The index in the array with the ignorable whitespace.</param>
            <param name="length">The length of the whitespaces.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.processingInstruction(System.String,System.String)">
            <summary>
            This method manage the event when a processing instruction were found.
            </summary>
            <param name="target">The processing instruction target.</param>
            <param name="data">The processing instruction data.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.setDocumentLocator(NHapi.Base.IXmlSaxLocator)">
            <summary>
            Receive an object for locating the origin of events into the XML document.
            </summary>
            <param name="locator">A 'XmlSaxLocator' object that can return the location of any events into the XML document.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.skippedEntity(System.String)">
            <summary>
            This method manage the event when a skipped entity was found.
            </summary>
            <param name="name">The name of the skipped entity.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.startDocument">
            <summary>
            This method manage the event when a start document node were found.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.startElement(System.String,System.String,System.String,NHapi.Base.SaxAttributesSupport)">
            <summary>
            This method manage the event when a start element node were found.
            </summary>
            <param name="namespaceURI">The namespace uri of the element tag.</param>
            <param name="localName">The local name of the element.</param>
            <param name="qName">The Qualify (long) name of the element.</param>
            <param name="qAtts">The list of attributes of the element.</param>
        </member>
        <member name="M:NHapi.Base.XmlSaxParserAdapter.startPrefixMapping(System.String,System.String)">
            <summary>
            This methods indicates the start of a prefix area in the XML document.
            </summary>
            <param name="prefix">The prefix of the area.</param>
            <param name="uri">The namespace URI of the prefix area.</param>
        </member>
        <member name="T:NHapi.Base.XmlSAXDocumentManager">
            <summary>
            Emulates the SAX parsers behaviours.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.#ctor">
            <summary>
            Public constructor for the class.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.NewInstance">
            <summary>
            Returns a new instance of 'XmlSAXDocumentManager'.
            </summary>
            <returns>A new 'XmlSAXDocumentManager' instance.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.CloneInstance(NHapi.Base.XmlSAXDocumentManager)">
            <summary>
            Returns a clone instance of 'XmlSAXDocumentManager'.
            </summary>
            <returns>A clone 'XmlSAXDocumentManager' instance.</returns>
        </member>
        <member name="P:NHapi.Base.XmlSAXDocumentManager.IsValidating">
            <summary>
            Indicates whether the 'XmlSAXDocumentManager' are validating the XML over a DTD.
            </summary>
        </member>
        <member name="P:NHapi.Base.XmlSAXDocumentManager.NamespaceAllowed">
            <summary>
            Indicates whether the 'XmlSAXDocumentManager' manager allows namespaces.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.UpdateLocatorData(NHapi.Base.XmlSaxLocatorImpl,System.Xml.XmlTextReader)">
            <summary>
            Emulates the behaviour of a SAX LocatorImpl object.
            </summary>
            <param name="locator">The 'XmlSaxLocatorImpl' instance to assign the document location.</param>
            <param name="textReader">The XML document instance to be used.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.setFeature(System.String,System.Boolean)">
            <summary>
            Emulates the behavior of a SAX parsers. Set the value of a feature.
            </summary>
            <param name="name">The feature name, which is a fully-qualified URI.</param>
            <param name="value">The requested value for the feature.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.getFeature(System.String)">
            <summary>
            Emulates the behavior of a SAX parsers. Gets the value of a feature.
            </summary>
            <param name="name">The feature name, which is a fully-qualified URI.</param>
            <returns>The requested value for the feature.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.setProperty(System.String,System.Object)">
            <summary>
            Emulates the behavior of a SAX parsers. Sets the value of a property.
            </summary>
            <param name="name">The property name, which is a fully-qualified URI.</param>
            <param name="value">The requested value for the property.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.getProperty(System.String)">
            <summary>
            Emulates the behavior of a SAX parsers. Gets the value of a property.
            </summary>
            <param name="name">The property name, which is a fully-qualified URI.</param>
            <returns>The requested value for the property.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.DoParsing">
            <summary>
            Emulates the behavior of a SAX parser, it realizes the callback events of the parser.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.FileInfo,NHapi.Base.IXmlSaxContentHandler)">
            <summary>
            Parses the specified file and process the events over the specified handler.
            </summary>
            <param name="filepath">The file to be used.</param>
            <param name="handler">The handler that manages the parser events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.String,NHapi.Base.IXmlSaxContentHandler)">
            <summary>
            Parses the specified file path and process the events over the specified handler.
            </summary>
            <param name="filepath">The path of the file to be used.</param>
            <param name="handler">The handler that manage the parser events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.Stream,NHapi.Base.IXmlSaxContentHandler)">
            <summary>
            Parses the specified stream and process the events over the specified handler.
            </summary>
            <param name="stream">The stream with the XML.</param>
            <param name="handler">The handler that manage the parser events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.Stream,NHapi.Base.IXmlSaxContentHandler,System.String)">
            <summary>
            Parses the specified stream and process the events over the specified handler, and resolves the
            entities with the specified URI.
            </summary>
            <param name="stream">The stream with the XML.</param>
            <param name="handler">The handler that manage the parser events.</param>
            <param name="URI">The namespace URI for resolve external entities.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(NHapi.Base.XmlSourceSupport,NHapi.Base.IXmlSaxContentHandler)">
            <summary>
            Parses the specified 'XmlSourceSupport' instance and process the events over the specified handler,
            and resolves the entities with the specified URI.
            </summary>
            <param name="source">The 'XmlSourceSupport' that contains the XML.</param>
            <param name="handler">The handler that manages the parser events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.FileInfo)">
            <summary>
            Parses the specified file and process the events over previously specified handler.
            </summary>
            <param name="filepath">The file with the XML.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.String)">
            <summary>
            Parses the specified file path and processes the events over previously specified handler.
            </summary>
            <param name="filepath">The path of the file with the XML.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.Stream)">
            <summary>
            Parses the specified stream and process the events over previously specified handler.
            </summary>
            <param name="stream">The stream with the XML.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(System.IO.Stream,System.String)">
            <summary>
            Parses the specified stream and processes the events over previously specified handler, and resolves the
            external entities with the specified URI.
            </summary>
            <param name="stream">The stream with the XML.</param>
            <param name="URI">The namespace URI for resolve external entities.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.parse(NHapi.Base.XmlSourceSupport)">
            <summary>
            Parses the specified 'XmlSourceSupport' and processes the events over the specified handler, and
            resolves the entities with the specified URI.
            </summary>
            <param name="source">The 'XmlSourceSupport' instance with the XML.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.ValidationEventHandle(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
            Manages all the exceptions that were thrown when the validation over XML fails.
            </summary>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.setContentHandler(NHapi.Base.IXmlSaxContentHandler)">
            <summary>
            Assigns the object that will handle all the content events.
            </summary>
            <param name="handler">The object that handles the content events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.setErrorHandler(NHapi.Base.IXmlSaxErrorHandler)">
            <summary>
            Assigns the object that will handle all the error events.
            </summary>
            <param name="handler">The object that handles the errors events.</param>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.getContentHandler">
            <summary>
            Obtains the object that will handle all the content events.
            </summary>
            <returns>The object that handles the content events.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.getErrorHandler">
            <summary>
            Assigns the object that will handle all the error events.
            </summary>
            <returns>The object that handles the error events.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.getEntityResolver">
            <summary>
            Returns the current entity resolver.
            </summary>
            <returns>The current entity resolver, or null if none has been registered.</returns>
        </member>
        <member name="M:NHapi.Base.XmlSAXDocumentManager.setEntityResolver(NHapi.Base.IXmlSaxEntityResolver)">
            <summary>
            Allows an application to register an entity resolver.
            </summary>
            <param name="resolver">The entity resolver.</param>
        </member>
        <member name="T:NHapi.Base.SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.WriteStackTrace(System.Exception,System.IO.TextWriter)">
            <summary>
            Writes the exception stack trace to the received stream.
            </summary>
            <param name="throwable">Exception to obtain information from.</param>
            <param name="stream">Output stream used to write to.</param>
        </member>
        <member name="T:NHapi.Base.SupportClass.StackSupport">
            <summary>
            SupportClass for the Stack class.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.StackSupport.Pop(System.Collections.ArrayList)">
            <summary>
            Removes the element at the top of the stack and returns it.
            </summary>
            <param name="stack">The stack where the element at the top will be returned and removed.</param>
            <returns>The element at the top of the stack.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.GetCharsFromString(System.String,System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Copies an array of chars obtained from a String into a specified array of chars.
            </summary>
            <param name="sourceString">The String to get the chars from.</param>
            <param name="sourceStart">Position of the String to start getting the chars.</param>
            <param name="sourceEnd">Position of the String to end getting the chars.</param>
            <param name="destinationArray">Array to return the chars.</param>
            <param name="destinationStart">Position of the destination array of chars to start storing the chars.</param>
            <returns>An array of chars.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.CharsAreUnique(System.String)">
            <summary>
            Evaluates if a string is comprised of unique characters.
            </summary>
            <param name="input">string to evaluate.</param>
            <returns>True if all characters are unique, otherwise False.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="input"/> is null or empty.</exception>
        </member>
        <member name="T:NHapi.Base.SupportClass.ICollectionSupport">
            <summary>
            This class provides functionality not found in .NET collection-related interfaces.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.Add(System.Collections.ICollection,System.Object)">
            <summary>
            Adds a new element to the specified collection.
            </summary>
            <param name="c">Collection where the new element will be added.</param>
            <param name="obj">Object to add.</param>
            <returns>true.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.AddAll(System.Collections.ICollection,System.Collections.ICollection)">
            <summary>
            Adds all of the elements of the "c" collection to the "target" collection.
            </summary>
            <param name="target">Collection where the new elements will be added.</param>
            <param name="c">Collection whose elements will be added.</param>
            <returns>Returns true if at least one element was added, false otherwise.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.Clear(System.Collections.ICollection)">
            <summary>
            Removes all the elements from the collection.
            </summary>
            <param name="c">The collection to remove elements.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.Contains(System.Collections.ICollection,System.Object)">
            <summary>
            Determines whether the collection contains the specified element.
            </summary>
            <param name="c">The collection to check.</param>
            <param name="obj">The object to locate in the collection.</param>
            <returns>true if the element is in the collection.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.ContainsAll(System.Collections.ICollection,System.Collections.ICollection)">
            <summary>
            Determines whether the collection contains all the elements in the specified collection.
            </summary>
            <param name="target">The collection to check.</param>
            <param name="c">Collection whose elements would be checked for containment.</param>
            <returns>true id the target collection contains all the elements of the specified collection.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.Remove(System.Collections.ICollection,System.Object)">
            <summary>
            Removes the specified element from the collection.
            </summary>
            <param name="c">The collection where the element will be removed.</param>
            <param name="obj">The element to remove from the collection.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.RemoveAll(System.Collections.ICollection,System.Collections.ICollection)">
            <summary>
            Removes all the elements from the specified collection that are contained in the target collection.
            </summary>
            <param name="target">Collection where the elements will be removed.</param>
            <param name="c">Elements to remove from the target collection.</param>
            <returns>true.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.RetainAll(System.Collections.ICollection,System.Collections.ICollection)">
            <summary>
            Retains the elements in the target collection that are contained in the specified collection.
            </summary>
            <param name="target">Collection where the elements will be removed.</param>
            <param name="c">Elements to be retained in the target collection.</param>
            <returns>true.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.ToArray(System.Collections.ICollection)">
            <summary>
            Returns an array containing all the elements of the collection.
            </summary>
            <returns>The array containing all the elements of the collection.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.ToArray(System.Collections.ICollection,System.Object[])">
            <summary>
            Obtains an array containing all the elements of the collection.
            </summary>
            <param name="objects">The array into which the elements of the collection will be stored.</param>
            <param name="c"></param>
            <returns>The array containing all the elements of the collection.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ICollectionSupport.ToArrayList(System.Collections.ICollection)">
            <summary>
            Converts an ICollection instance to an ArrayList instance.
            </summary>
            <param name="c">The ICollection instance to be converted.</param>
            <returns>An ArrayList instance in which its elements are the elements of the ICollection instance.</returns>
        </member>
        <member name="T:NHapi.Base.SupportClass.ISetSupport">
            <summary>
            Represents a collection ob objects that contains no duplicate elements.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ISetSupport.Add(System.Object)">
            <summary>
            Adds a new element to the Collection if it is not already present.
            </summary>
            <param name="obj">The object to add to the collection.</param>
            <returns>Returns true if the object was added to the collection, otherwise false.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ISetSupport.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements of the specified collection to the Set.
            </summary>
            <param name="c">Collection of objects to add.</param>
            <returns>true.</returns>
        </member>
        <member name="T:NHapi.Base.SupportClass.HashSetSupport">
            <summary>
            SupportClass for the HashSet class.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.HashSetSupport.Add(System.Object)">
            <summary>
            Adds a new element to the ArrayList if it is not already present.
            </summary>
            <param name="obj">Element to insert to the ArrayList.</param>
            <returns>Returns true if the new element was inserted, false otherwise.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.HashSetSupport.AddAll(System.Collections.ICollection)">
            <summary>
            Adds all the elements of the specified collection that are not present to the list.
            </summary>
            <param name="c">Collection where the new elements will be added.</param>
            <returns>Returns true if at least one element was added, false otherwise.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.HashSetSupport.Clone">
            <summary>
            Returns a copy of the HashSet instance.
            </summary>
            <returns>Returns a shallow copy of the current HashSet.</returns>
        </member>
        <member name="T:NHapi.Base.SupportClass.CalendarManager">
            <summary>
            This class manages different features for calendars.
            The different calendars are internally managed using a hash table structure.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.YEAR">
            <summary>
            Field used to get or set the year.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.MONTH">
            <summary>
            Field used to get or set the month.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.DATE">
            <summary>
            Field used to get or set the day of the month.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.HOUR">
            <summary>
            Field used to get or set the hour of the morning or afternoon.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.MINUTE">
            <summary>
            Field used to get or set the minute within the hour.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.SECOND">
            <summary>
            Field used to get or set the second within the minute.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.MILLISECOND">
            <summary>
            Field used to get or set the millisecond within the second.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.DAY_OF_YEAR">
            <summary>
            Field used to get or set the day of the year.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.DAY_OF_MONTH">
            <summary>
            Field used to get or set the day of the month.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.DAY_OF_WEEK">
            <summary>
            Field used to get or set the day of the week.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.HOUR_OF_DAY">
            <summary>
            Field used to get or set the hour of the day.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.AM_PM">
            <summary>
            Field used to get or set whether the HOUR is before or after noon.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.AM">
            <summary>
            Field used to get or set the value of the AM_PM field which indicates the period of the day from midnight to just before noon.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.PM">
            <summary>
            Field used to get or set the value of the AM_PM field which indicates the period of the day from noon to just before midnight.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.manager">
            <summary>
            The hash table that contains the calendars and its properties.
            </summary>
        </member>
        <member name="T:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable">
            <summary>
            Internal class that inherits from HashTable to manage the different calendars.
            This structure will contain an instance of System.Globalization.Calendar that represents
            a type of calendar and its properties (represented by an instance of CalendarProperties
            class).
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.GetDateTime(System.Globalization.Calendar)">
            <summary>
            Gets the calendar current date and time.
            </summary>
            <param name="calendar">The calendar to get its current date and time.</param>
            <returns>A System.DateTime value that indicates the current date and time for the
            calendar given.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.SetDateTime(System.Globalization.Calendar,System.DateTime)">
            <summary>
            Sets the specified System.DateTime value to the specified calendar.
            </summary>
            <param name="calendar">The calendar to set its date.</param>
            <param name="date">The System.DateTime value to set to the calendar.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Set(System.Globalization.Calendar,System.Int32,System.Int32)">
            <summary>
            Sets the corresponding field in an specified calendar with the value given.
            If the specified calendar does not have exist in the hash table, it creates a
            new instance of the calendar with the current date and time and then assigns it
            the new specified value.
            </summary>
            <param name="calendar">The calendar to set its date or time.</param>
            <param name="field">One of the fields that composes a date/time.</param>
            <param name="fieldValue">The value to be set.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Set(System.Globalization.Calendar,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the corresponding date (day, month and year) to the calendar specified.
            If the calendar does not exist in the hash table, it creates a new instance and sets
            its values.
            </summary>
            <param name="calendar">The calendar to set its date.</param>
            <param name="year">Integer value that represent the year.</param>
            <param name="month">Integer value that represent the month.</param>
            <param name="day">Integer value that represent the day.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Set(System.Globalization.Calendar,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the corresponding date (day, month and year) and hour (hour and minute)
            to the calendar specified.
            If the calendar does not exist in the hash table, it creates a new instance and sets
            its values.
            </summary>
            <param name="calendar">The calendar to set its date and time.</param>
            <param name="year">Integer value that represent the year.</param>
            <param name="month">Integer value that represent the month.</param>
            <param name="day">Integer value that represent the day.</param>
            <param name="hour">Integer value that represent the hour.</param>
            <param name="minute">Integer value that represent the minutes.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Set(System.Globalization.Calendar,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the corresponding date (day, month and year) and hour (hour, minute and second)
            to the calendar specified.
            If the calendar does not exist in the hash table, it creates a new instance and sets
            its values.
            </summary>
            <param name="calendar">The calendar to set its date and time.</param>
            <param name="year">Integer value that represent the year.</param>
            <param name="month">Integer value that represent the month.</param>
            <param name="day">Integer value that represent the day.</param>
            <param name="hour">Integer value that represent the hour.</param>
            <param name="minute">Integer value that represent the minutes.</param>
            <param name="second">Integer value that represent the seconds.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Get(System.Globalization.Calendar,System.Int32)">
            <summary>
            Gets the value represented by the field specified.
            </summary>
            <param name="calendar">The calendar to get its date or time.</param>
            <param name="field">One of the field that composes a date/time.</param>
            <returns>The integer value for the field given.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.SetTimeInMilliseconds(System.Globalization.Calendar,System.Int64)">
            <summary>
            Sets the time in the specified calendar with the long value.
            </summary>
            <param name="calendar">The calendar to set its date and time.</param>
            <param name="milliseconds">A long value that indicates the milliseconds to be set to
            the hour for the calendar.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.GetFirstDayOfWeek(System.Globalization.Calendar)">
            <summary>
            Gets what the first day of the week is; e.g., Sunday in US, Monday in France.
            </summary>
            <param name="calendar">The calendar to get its first day of the week.</param>
            <returns>A System.DayOfWeek value indicating the first day of the week.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.SetFirstDayOfWeek(System.Globalization.Calendar,System.DayOfWeek)">
            <summary>
            Sets what the first day of the week is; e.g., Sunday in US, Monday in France.
            </summary>
            <param name="calendar">The calendar to set its first day of the week.</param>
            <param name="firstDayOfWeek">A System.DayOfWeek value indicating the first day of the week
            to be set.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Clear(System.Globalization.Calendar)">
            <summary>
            Removes the specified calendar from the hash table.
            </summary>
            <param name="calendar">The calendar to be removed.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.Clear(System.Globalization.Calendar,System.Int32)">
            <summary>
            Removes the specified field from the calendar given.
            If the field does not exists in the calendar, the calendar is removed from the table.
            </summary>
            <param name="calendar">The calendar to remove the value from.</param>
            <param name="field">The field to be removed from the calendar.</param>
        </member>
        <member name="T:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.CalendarProperties">
            <summary>
            Internal class that represents the properties of a calendar instance.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.CalendarProperties.dateTime">
            <summary>
            The date and time of a calendar.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.CalendarManager.CalendarHashTable.CalendarProperties.dateTimeFormat">
            <summary>
            The format for the date and time in a calendar.
            </summary>
        </member>
        <member name="T:NHapi.Base.SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.ThreadClass.threadField">
            <summary>
            The instance of System.Threading.Thread.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Name">The name of the thread.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing.</param>
            <param name="Name">The name of the thread.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.ThreadClass.Instance">
            <summary>
            Gets the current thread instance.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses.
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses.
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds.</param>
            <param name="NanoSeconds">Time of wait in nanoseconds.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread. Calling this method
            usually terminates the thread.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread while also providing
            exception information about the thread termination.
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current Object.
            </summary>
            <returns>A String that represents the current Object.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.ThreadClass.Current">
            <summary>
            Gets the currently running thread.
            </summary>
            <returns>The currently running thread.</returns>
        </member>
        <member name="T:NHapi.Base.SupportClass.Tokenizer">
            <summary>
            The class performs token processing in strings.
            </summary>
        </member>
        <member name="F:NHapi.Base.SupportClass.Tokenizer.currentPos">
            Position over the string
        </member>
        <member name="F:NHapi.Base.SupportClass.Tokenizer.includeDelims">
            Include delimiters in the results.
        </member>
        <member name="F:NHapi.Base.SupportClass.Tokenizer.chars">
            Char representation of the String to tokenize.
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.#ctor(System.String)">
            <summary>
            Initializes a new class instance with a specified string to process.
            </summary>
            <param name="source">String to tokenize.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.#ctor(System.String,System.String)">
            <summary>
            Initializes a new class instance with a specified string to process
            and the specified token delimiters to use.
            </summary>
            <param name="source">String to tokenize.</param>
            <param name="delimiters">String containing the delimiters.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Initializes a new class instance with a specified string to process, the specified token
            delimiters to use, and whether the delimiters must be included in the results.
            </summary>
            <param name="source">String to tokenize.</param>
            <param name="delimiters">String containing the delimiters.</param>
            <param name="includeDelims">Determines if delimiters are included in the results.</param>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.NextToken">
            <summary>
            Returns the next token from the token list.
            </summary>
            <returns>The string value of the token.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.NextToken(System.String)">
            <summary>
            Returns the next token from the source string, using the provided
            token delimiters.
            </summary>
            <param name="delimiters">String containing the delimiters to use.</param>
            <returns>The string value of the token.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.HasMoreTokens">
            <summary>
            Determines if there are more tokens to return from the source string.
            </summary>
            <returns>True or false, depending if there are more tokens.</returns>
        </member>
        <member name="P:NHapi.Base.SupportClass.Tokenizer.Count">
            <summary>
            Remaining tokens count.
            </summary>
        </member>
        <member name="P:NHapi.Base.SupportClass.Tokenizer.Current">
            <summary>
             Performs the same action as NextToken.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.MoveNext">
            <summary>
            Performs the same action as HasMoreTokens.
            </summary>
            <returns>True or false, depending if there are more tokens.</returns>
        </member>
        <member name="M:NHapi.Base.SupportClass.Tokenizer.Reset">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:NHapi.Base.SupportClass.FileLength(System.IO.FileInfo)">
            <summary>
            Checks if the giving File instance is a directory or file, and returns his Length.
            </summary>
            <param name="file">The File instance to check.</param>
            <returns>The length of the file.</returns>
        </member>
        <member name="T:NHapi.Base.Util.DeepCopy">
            <summary> Tools for copying data recursively from one message element into another.  Currently only Types are
            supported.
            </summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="M:NHapi.Base.Util.DeepCopy.Copy(NHapi.Base.Model.IType,NHapi.Base.Model.IType)">
            <summary> Copies data from the "from" Type into the "to" Type.  Either Type may be
            a Primitive, Composite, or Varies.  If a Varies is provided, the operation is
            performed on the result of calling its getData() method.  A Primitive may be
            copied into a Composite, in which case the value is copied into the first
            component of the Composite.  A Composite may be copied into a Primitive,
            in which case the first component is copied.  Given Composites with different
            numbers of components, the first components are copied, up to the length
            of the smaller one.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.DeepCopy.Copy(NHapi.Base.Model.ISegment,NHapi.Base.Model.ISegment)">
            <summary> Copies contents from the source segment to the destination segment.  This
            method calls copy(Type, Type) on each repetition of each field (see additional
            behavioural description there).  An attempt is made to copy each repetition of
            each field in the source segment, regardless of whether the corresponding
            destination field is repeating or even exists.
            </summary>
            <param name="from">the segment from which data are copied.
            </param>
            <param name="to">the segment into which data are copied.
            </param>
        </member>
        <member name="T:NHapi.Base.Util.FilterIterator">
            <summary>
            Filter iterator class.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.#ctor(System.Collections.IEnumerator,NHapi.Base.Util.FilterIterator.IPredicate)">
            <summary>
            Constructor.
            </summary>
            <param name="iter"></param>
            <param name="predicate"></param>
        </member>
        <member name="T:NHapi.Base.Util.FilterIterator.IPredicate">
            <summary>
            IPredicate interface.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.IPredicate.Evaluate(System.Object)">
            <summary>
            Evaluate the object.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHapi.Base.Util.FilterIterator.Current">
            <summary>
            The current item.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.MoveNext">
            <summary>
            Move next.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.Remove">
            <summary>Throws UnsupportedOperationException. </summary>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.Reset">
            <summary>
            Reset.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.FilterIterator.SetNextObject">
            <summary> Set nextObject to the next object. If there are no more
            objects then return false. Otherwise, return true.
            </summary>
        </member>
        <member name="T:NHapi.Base.Util.MessageIterator">
            <summary>
            Iterates over all defined nodes (ie segments, groups) in a message,
            regardless of whether they have been instantiated previously.  This is a
            tricky process, because the number of nodes is infinite, due to infinitely
            repeating segments and groups.  See. <code>next()</code> for details on
            how this is handled.
            <para>
            This implementation assumes that the first segment in each group is present (as per
            HL7 rules).  Specifically, when looking for a segment location, an empty group that has
            a spot for the segment will be overlooked if there is anything else before that spot.
            This may result in surprising (but sensible) behaviour if a message is missing the
            first segment in a group.
            </para>
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.#ctor(NHapi.Base.Model.IStructure,System.String,System.Boolean)">
            <summary>Creates a new instance of MessageIterator. </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Current">
            <summary> <p>Returns the next node in the message.  Sometimes the next node is
            ambiguous.  For example at the end of a repeating group, the next node
            may be the first segment in the next repetition of the group, or the
            next sibling, or an undeclared segment locally added to the group's end.
            Cases like this are disambiguated using getDirection(), which returns
            the name of the structure that we are "iterating towards".
            Usually we are "iterating towards" a segment of a certain name because we
            have a segment string that we would like to parse into that node.
            Here are the rules: </p>
            <ol><li>If at a group, next means first child.</li>
            <li>If at a non-repeating segment, next means next "position"</li>
            <li>If at a repeating segment: if segment name matches
            direction then next means next rep, otherwise next means next "position".</li>
            <li>If at a segment within a group (not at the end of the group), next "position"
            means next sibling</li>
            <li>If at the end of a group: If name of group or any of its "first
            descendants" matches direction, then next position means next rep of group.  Otherwise
            if direction matches name of next sibling of the group, or any of its first
            descendents, next position means next sibling of the group.  Otherwise, next means a
            new segment added to the group (with a name that matches "direction").  </li>
            <li>"First descendents" means first child, or first child of the first child,
            or first child of the first child of the first child, etc. </li> </ol>
            </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Direction">
            <summary>
            The direction.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.MatchExistsAfterPosition(NHapi.Base.Util.MessageIterator.Position,System.String,System.Boolean,System.Boolean)">
            <summary> A match exists for the given name somewhere after the given position (in the
            normal serialization order).
            </summary>
            <param name="pos">the message position after which to look (note that this specifies
            the message instance).
            </param>
            <param name="name">the name of the structure to look for.
            </param>
            <param name="firstDescendentsOnly">only searches the first children of a group.
            </param>
            <param name="upToFirstRequired">only searches the children of a group up to the first
            required child (normally the first one).  This is used when we are parsing
            a message in order and looking for a place to parse a particular segment --
            if the message is correct then it can't go after a required position of a
            different name.
            </param>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.GetIndex(NHapi.Base.Model.IGroup,NHapi.Base.Model.IStructure)">
            <summary> Returns the index of the given structure as a child of the
            given parent.  Returns null if the child isn't found.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Contains(NHapi.Base.Model.IStructure,System.String,System.Boolean,System.Boolean)">
            <summary> Determines whether the given structure matches the given name, or contains
            a child that does.
            </summary>
            <param name="s">the structure to check.
            </param>
            <param name="name">the name to look for.
            </param>
            <param name="firstDescendentsOnly">only checks first descendents (i.e. first
            child, first child of first child, etc.)  In theory the first child
            of a group should always be present, and we don't use this method with
            subsequent children because finding the next position within a group is
            straightforward.
            </param>
            <param name="upToFirstRequired">only checks first descendents and of their siblings
            up to the first required one.  This may be needed because in practice
            some first children of groups are not required.
            </param>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.IsLast(NHapi.Base.Util.MessageIterator.Position)">
            <summary> Tests whether the name of the given Index matches
            the name of the last child of the given group.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Remove">
            <summary>Not supported. </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.MoveNext">
            <summary> Returns true if another object exists in the iteration sequence.  </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Reset">
            <summary>
            Reset the iterator.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.NextSibling(NHapi.Base.Util.MessageIterator.Position)">
            <summary> Sets the next location to the next sibling of the given
            index.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.NewSegment(NHapi.Base.Model.IGroup,System.String)">
            <summary> Sets the next position to a new segment of the given name, within the
            given group.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.GroupNext(NHapi.Base.Model.IGroup)">
            <summary> Sets next to the first child of the given group (iteration
            always proceeds from group to first child).
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.NextRep(NHapi.Base.Util.MessageIterator.Position)">
            <summary> Sets next to the next repetition of the current structure.  </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.NextPosition(NHapi.Base.Util.MessageIterator.Position,System.String,System.Boolean)">
            <summary> Sets this.next to the next position in the message (from the given position),
            which could be the next sibling, a new segment, or the next rep
            of the parent.  See next() for details.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.NextFromGroupEnd(NHapi.Base.Util.MessageIterator.Position,System.String,System.Boolean)">
            <summary>Navigates from end of group. </summary>
        </member>
        <member name="T:NHapi.Base.Util.MessageIterator.Index">
            <summary> An index of a child structure within a group, consisting of the name and rep of
            of the child.
            </summary>
        </member>
        <member name="F:NHapi.Base.Util.MessageIterator.Index.name">
            <summary>
            The name.
            </summary>
        </member>
        <member name="F:NHapi.Base.Util.MessageIterator.Index.rep">
            <summary>
            The repetition.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Index.#ctor(System.String,System.Int32)">
            <summary>
            The index.
            </summary>
            <param name="name">name.</param>
            <param name="rep">repetition.</param>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Index.Name">
            <summary>
            Gets or sets the name.
            </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Index.Rep">
            <summary>
            Gets or sets the repetition.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Index.Equals(System.Object)">
            <summary>
            Override equals.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Index.GetHashCode">
            <summary>
            Override has code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Index.ToString">
            <summary>
            Override to string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Util.MessageIterator.Position">
            <summary> A structure position within a message. </summary>
        </member>
        <member name="F:NHapi.Base.Util.MessageIterator.Position.parent">
            <summary>
            The parent.
            </summary>
        </member>
        <member name="F:NHapi.Base.Util.MessageIterator.Position.index">
            <summary>
            The index.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Position.#ctor(NHapi.Base.Model.IGroup,System.String,System.Int32)">
            <summary>
            The position of the element.
            </summary>
            <param name="parent">Parent.</param>
            <param name="name">Name.</param>
            <param name="rep">Repetition.</param>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Position.#ctor(NHapi.Base.Model.IGroup,NHapi.Base.Util.MessageIterator.Index)">
            <summary>
            The position of the element.
            </summary>
            <param name="parent">Parent.</param>
            <param name="i">index.</param>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Position.Parent">
            <summary>
            Gets or sets the parent.
            </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageIterator.Position.Index">
            <summary>
            Gets or sets the index.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Position.Equals(System.Object)">
            <summary>
            Override equals operator.
            </summary>
            <param name="obj">Object obj.</param>
            <returns>true if objects are equal.</returns>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Position.GetHashCode">
            <summary>
            Override hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHapi.Base.Util.MessageIterator.Position.ToString">
            <summary>
            Override to string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Util.MessageNavigator">
            <summary> <p>Used to navigate the nested group structure of a message.  This is an alternate
            way of accessing parts of a message, ie rather than getting a segment through
            a chain of getXXX() calls on the message, you can create a MessageNavigator
            for the message, "navigate" to the desired segment, and then call
            getCurrentStructure() to get the segment you have navigated to.  A message
            navigator always has a "current location" pointing to some structure location (segment
            or group location) within the message.  Note that a location exists whether or
            not there are any instances of the structure at that location. </p>
            <p>This class is used by Terser, which presents an even more convenient way
            of navigating a message.  </p>
            <p>This class also has an iterate() method, which iterates over
            segments (and optionally groups).  </p>
            </summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.#ctor(NHapi.Base.Model.IGroup)">
            <summary> Creates a new instance of MessageNavigator.</summary>
            <param name="root">the root of navigation -- may be a message or a group
            within a message.  Navigation will only occur within the subtree
            of which the given group is the root.
            </param>
        </member>
        <member name="P:NHapi.Base.Util.MessageNavigator.Root">
            <summary>
            THe root element of this message.
            </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageNavigator.CurrentGroup">
            <summary> Returns the group within which the pointer is currently located.
            If at the root, the root is returned.
            </summary>
        </member>
        <member name="P:NHapi.Base.Util.MessageNavigator.CurrentChildReps">
            <summary> Returns the array of structures at the current location.
            Throws an exception if pointer is at root.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.DrillDown(System.Int32,System.Int32)">
            <summary> Drills down into the group at the given index within the current
            group -- ie sets the location pointer to the first structure within the child.
            </summary>
            <param name="childNumber">the index of the group child into which to drill.
            </param>
            <param name="rep">the group repetition into which to drill.
            </param>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.DrillDown(System.Int32)">
            <summary> Drills down into the group at the CURRENT location.</summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.DrillUp">
            <summary> Switches the group context to the parent of the current group,
            and sets the child pointer to the next sibling.
            </summary>
            <returns> false if already at root.
            </returns>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.HasNextChild">
            <summary>
            Returns true if there is a sibling following the current location.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.NextChild">
            <summary> Moves to the next sibling of the current location.</summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.ToChild(System.Int32)">
            <summary> Moves to the sibling of the current location at the specified index.</summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.Reset">
            <summary>Resets the location to the beginning of the tree (the root). </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.GetCurrentStructure(System.Int32)">
            <summary> Returns the given rep of the structure at the current location.
            If at root, always returns the root (the rep is ignored).
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.Iterate(System.Boolean,System.Boolean)">
            <summary> Iterates through the message tree to the next segment/group location (regardless
            of whether an instance of the segment exists).  If the end of the tree is
            reached, starts over at the root.  Only enters the first repetition of a
            repeating group -- explicit navigation (using the drill...() methods) is
            necessary to get to subsequent reps.
            </summary>
            <param name="segmentsOnly">if true, only stops at segments (not groups).
            </param>
            <param name="loop">if true, loops back to beginning when end of msg reached; if false,
            throws HL7Exception if end of msg reached.
            </param>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.DrillHere(NHapi.Base.Model.IStructure)">
            <summary> Navigates to a specific location in the message.</summary>
        </member>
        <member name="M:NHapi.Base.Util.MessageNavigator.Search(System.String[],System.Object)">
            <summary>Like Arrays.binarySearch, only probably slower and doesn't require
            a sorted list.  Also just returns -1 if item isn't found.
            </summary>
        </member>
        <member name="T:NHapi.Base.Util.MessageNavigator.GroupContext">
            <summary> A structure to hold current location information at
            one level of the message tree.  A stack of these
            identifies the current location completely.
            </summary>
        </member>
        <member name="T:NHapi.Base.Util.SegmentFinder">
            <summary> A tool for getting segments by name within a message or part of a message.</summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.#ctor(NHapi.Base.Model.IGroup)">
            <summary> Creates a new instance of SegmentFinder.</summary>
            <param name="root">the scope of searches -- may be a whole message or only a branch.
            </param>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.FindSegment(System.String,System.Int32)">
            <summary>
            Returns the first segment with a name that matches the given pattern, in a depth-first search.
            Repeated searches are initiated from the location just AFTER where the last segment was found.
            Call reset() is this is not desired.  Note: this means that the current location will not be found.
            </summary>
            <param name="namePattern">
            The name of the segment to find. The wildcard * means any number
            of arbitrary characters; the wildcard ? one arbitrary character
            (eg "P*" or "*ID" or "???" or "P??" would match on PID).
            </param>
            <param name="rep">the repetition of the segment to return.</param>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.FindGroup(System.String,System.Int32)">
            <summary> As findSegment(), but will only return a group.</summary>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.GetSegment(System.String,System.Int32)">
            <summary>
            Returns the first segment with a name matching the given pattern that is a sibling of
            the structure at the current location. Other parts of the message are
            not searched (in contrast to findSegment).
            As a special case, if the pointer is at the root, the children of the root
            are searched.
            </summary>
            <param name="namePattern">
            The name of the segment to get. The wildcard * means any number
            of arbitrary characters; the wildcard ? one arbitrary character
            (eg "P*" or "*ID" or "???" or "P??" would match on PID).
            </param>
            <param name="rep">the repetition of the segment to return.</param>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.GetGroup(System.String,System.Int32)">
            <summary> As getSegment() but will only return a group.</summary>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.FindStructure(System.String,System.Int32)">
            <summary> Returns the first matching structure AFTER the current position.</summary>
        </member>
        <member name="M:NHapi.Base.Util.SegmentFinder.Matches(System.String,System.String)">
            <summary> Tests whether the given name matches the given pattern.</summary>
        </member>
        <member name="T:NHapi.Base.Util.Terser">
            <summary>
            Wraps a message to provide access to fields using a terse location specification syntax.
            </summary>
            <example>
            <para>
            For example:
            <code>terser.set("MSH-9-3", "ADT_A01");</code> <br />
            can be used instead of. <br />
            <code>message.getMSH().getMessageType().getMessageStructure().setValue("ADT_A01"); </code>
            </para>
            <para>
            The syntax of a location spec is as follows: <br />
            location_spec: <code>segment_path_spec "-" field ["(" rep ")"] ["-" component ["-" subcomponent]] </code> <br />
            ... where rep, field, component, and subcomponent are integers (representing, respectively,
            the field repetition (starting at 0), and the field number, component number, and subcomponent
            numbers (starting at 1).  Omitting the rep is equivalent to specifying 0; omitting the
            component or subcomponent is equivalent to specifying 1.
            </para>
            <para>
            The syntax for the segment_path_spec is as follows: <br />
            segment_path_spec: <code> ["/"] (group_spec ["(" rep ")"] "/")* segment_spec ["(" rep ")"]</code><br />
            ... where rep has the same meaning as for fields.  A leading "/" indicates that navigation to the
            location begins at the root of the message; omitting this indicates that navigation begins at the
            current location of the underlying SegmentFinder (see getFinder() -- this allows manual navigation
            if desired).
            </para>
            <para>
            The syntax for group_spec is: <br />
            group_spec: <code>["."] group_name_pattern</code><br />
            Here, a . indicates that the group should be searched for (using a SegmentFinder) starting at the
            current location in the message.  The wildcards "*" and "?" represent any number of arbitrary characters,
            and a single arbitrary character, respectively.  For example, "M*" and "?S?" match MSH.  The first
            group with a name that matches the given group_name_pattern will be matched.
            </para>
            <para>
            The segment_spec is analogous to the group_spec. <br />
            As another example, the following subcomponent in an SIU_S12 message: <br />
            <code>msg.getSIU_S12_RGSAISNTEAIGNTEAILNTEAIPNTE(1).getSIU_S12_AIGNTE().getAIG().getResourceGroup(1).getIdentifier();</code><br />
            ... is referenced by all of the following location_spec: <br />
            <code>
            /SIU_S12_RGSAISNTEAIGNTEAILNTEAIPNTE(1)/SIU_S12_AIGNTE/AIG-5(1)-1 <br/>
            /*AIG*(1)/SIU_S12_AIGNTE/AIG-5(1)-1 <br/>
            /*AIG*(1)/.AIG-5(1)
            </code>
            </para>
            <para>
            The search function only iterates through rep 0 of each group. Thus if rep 0 of the first group
            in this example was desired instead of rep 1, the following syntax would also work (since there is
            only one AIG segment position in SUI_S12): <code>/.AIG-5(1)</code>
            </para>
            </example>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Util.Terser.#ctor(NHapi.Base.Model.IMessage)">
            <summary>Creates a new instance of Terser. </summary>
        </member>
        <member name="P:NHapi.Base.Util.Terser.Finder">
            <summary>
            Returns the segment finder used by this Terser.  Navigating the
            finder will influence the behaviour of the Terser accordingly. ie:
            when the full path of the segment is not specified the segment will
            be sought beginning at the current location of the finder.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.Get(NHapi.Base.Model.ISegment,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the string value of the Primitive at the given location.
            </summary>
            <param name="segment">the segment from which to get the primitive.</param>
            <param name="field">the field number.</param>
            <param name="rep">the field repetition.</param>
            <param name="component">the component number (use 1 for primitive field).</param>
            <param name="subcomponent">the Subcomponent number (use 1 for primitive component).</param>
        </member>
        <member name="M:NHapi.Base.Util.Terser.Set(NHapi.Base.Model.ISegment,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary> Sets the string value of the Primitive at the given location.</summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetPrimitive(NHapi.Base.Model.IType,System.Int32,System.Int32)">
            <summary> Returns the Primitive object at the given location in the given field.
            It is intended that the given type be at the field level, although extra components
            will be added blindly if, for example, you provide a primitive subcomponent instead
            and specify component or subcomponent > 1.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetIndices(System.String)">
            <summary>
            Given a Terser path, returns an array containing field num, field rep,
            component, and subcomponent.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.NumSubComponents(NHapi.Base.Model.IType,System.Int32)">
            <summary>
            Returns the number of sub-components in the specified component, ie:
            the number of standard sub-components (e.g. 6 for CE) plus any extra components that
            that have been added at runtime.
            </summary>
            <param name="type"></param>
            <param name="component">numbered from 1.</param>
        </member>
        <member name="M:NHapi.Base.Util.Terser.NumComponents(NHapi.Base.Model.IType)">
            <summary> Returns the number of components in the given type, i.e. the
            number of standard components (e.g. 6 for CE) plus any extra components that
            have been added at runtime.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.Get(System.String)">
            <summary>
            Gets the string value of the field specified. See the class docs for syntax
            of the location spec.
            <para>
            If a repetition is omitted for a repeating segment or field, the first rep is used.
            If the component or subcomponent is not specified for a composite field, the first
            component is used (this allows one to write code that will work with later versions of
            the HL7 standard).
            </para>
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetSegment(System.String)">
            <summary> Returns the segment specified in the given segment_path_spec. </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.Set(System.String,System.String)">
            <summary> Sets the string value of the field specified.  See class docs for location spec syntax.</summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetPrimitive(NHapi.Base.Model.ISegment,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the Primitive object at the given location.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetPrimitive(NHapi.Base.Model.IType)">
            <summary> Attempts to extract a Primitive from the given type. If it's a composite,
            drills down through first components until a primitive is reached.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.GetComponent(NHapi.Base.Model.IType,System.Int32)">
            <summary> Returns the component (or sub-component, as the case may be) at the given
            index.  If it does not exist, it is added as an "extra component".
            If comp > 1 is requested from a Varies with GenericPrimitive data, the
            data is set to GenericComposite (this avoids the creation of a chain of
            ExtraComponents on GenericPrimitives).
            Components are numbered from 1.
            </summary>
        </member>
        <member name="M:NHapi.Base.Util.Terser.ParsePathSpec(System.String)">
            <summary>Gets path information from a path spec. </summary>
        </member>
        <member name="T:NHapi.Base.Util.Terser.PathSpec">
            <summary>Struct for information about a step in a segment path. </summary>
        </member>
        <member name="T:NHapi.Base.Validation.IEncodingRule">
            <summary>
            A validation rule that applies to encoded message strings. Rules that
            apply to message content are not included in this category (they are MessageRules
            and are evaluated against parsed Message object). EncodingRules are intended
            for criteria that are specific to the encoded form of a message, e.g. "no empty
            tags in an XML message".
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Validation.IEncodingRule.Test(System.String)">
            <summary>
            Tests the given encoded message text against the criteria
            defined by this rule class.
            </summary>
            <returns>
            A list of exceptions indicating points at which the given
            message failed to validate (empty if validation succeeds; may
            not be a complete list as testing may be aborted after failure).
            </returns>
        </member>
        <member name="T:NHapi.Base.Validation.IMessageRule">
            <summary>
            A validation rule that applies to a fully populated message object. Message rules
            may be called (depending on runtime configuration) just after an inbound message
            is parsed, or just before an outbound message is encoded.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Validation.IMessageRule.Test(NHapi.Base.Model.IMessage)">
            <summary>
            Tests the given (fully populated) message against the criteria
            defined by this rule class.
            </summary>
            <returns>
            A list of exceptions indicating points at which the given
            message failed to validate (empty if validation succeeds; may
            not be a complete list as testing may be aborted after failure).
            The list should be empty if this rule is evaluated against a type
            of message to which it doesn't apply.
            </returns>
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.DefaultValidation">
             <summary> A. <code>ValidationContext</code> with a default set of rules initially defined.
             This can be used as-is for a reasonable level of primitive type validation.
            
             </summary>
             <author>  <a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a>
             </author>
             <version>  $Revision: 1.1 $ updated on $Date: 2005/06/14 20:13:16 $ by $Author: bryan_tripp $.
             </version>
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.RegexPrimitiveRule">
            <summary>
            A <see cref="T:NHapi.Base.Validation.IPrimitiveTypeRule"/> that validates primitive values
            using a regular expression.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.3 $ updated on $Date: 2005/06/14 20:15:12 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.#ctor(System.String,System.String)">
            <param name="theRegex">a regular expression against which to validate primitive
            values.
            </param>
            <param name="theSectionReference">to be returned by. <code>getSectionReference()</code>
            </param>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.Description">
            <summary>
            Gets the rule description.
            </summary>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.SectionReference">
            <summary>
            Gets the section reference.
            </summary>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.Test(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.correct(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RegexPrimitiveRule.Correct(System.String)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.RuleBinding">
            <summary>
            An association between a type of item to be validated (eg a datatype or
            message) and a validation <see cref="T:NHapi.Base.Validation.IRule"/>.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.3 $ updated on $Date: 2005/06/14 20:16:01 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RuleBinding.#ctor(System.String,System.String,NHapi.Base.Validation.IRule)">
             <summary> Active by default.
            
             </summary>
             <param name="theVersion">see {@link #getVersion()}.
             </param>
             <param name="theScope">see {@link #getScope()}.
             </param>
             <param name="theRule">see {@link #getRule()}.
             </param>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RuleBinding.Active">
            <summary>
            Gets or sets a value indicating whether or not the binding is currently active.
            </summary>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RuleBinding.Version">
            <summary>
            Gets the version to which the binding applies (* means all versions).
            </summary>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RuleBinding.Scope">
            <summary>
            Gets the scope of item types to which the rule applies.
            </summary>
            <remarks>
            <para>
            For <see cref="T:NHapi.Base.Validation.IMessageRule"/> this is the message type and trigger event,
            separated by a ^ (either value may be *, meaning any).
            </para>
            <para>
            For <see cref="T:NHapi.Base.Validation.IPrimitiveTypeRule"/> this is the datatype name (* means any).
            </para>
            <para>
            For <see cref="T:NHapi.Base.Validation.IEncodingRule"/> this is the encoding name (again, * means any).
            </para>
            </remarks>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.RuleBinding.Rule">
            <summary>
            Gets the rule that applies to the associated version and scope.
            </summary>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RuleBinding.AppliesToVersion(System.String)">
            <param name="theVersion">an HL7 version.
            </param>
            <returns> true if this binding applies to the given version (ie getVersion() matches or is *).
            </returns>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RuleBinding.AppliesToScope(System.String)">
            <param name="theType">an item description to be checked against getScope().
            </param>
            <returns> true if the given type is within scope, ie if it matches getScope() or getScope() is *.
            </returns>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.RuleBinding.Applies(System.String,System.String)">
            <summary>
            An abstraction of appliesToVersion() and appliesToScope().
            </summary>
            <param name="theBindingData"></param>
            <param name="theItemData"></param>
            <returns></returns>
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.SizeRule">
            <summary>
            Checks that Primitive values conform to a certain size limit.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.3 $ updated on $Date: 2005/06/14 20:16:01 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.SizeRule.#ctor(System.Int32)">
            <param name="theMaxChars">the maximum number of characters this rule allows in a
            primitive value.
            </param>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.SizeRule.Description">
            <summary>
            Gets the rule description.
            </summary>
            <seealso cref="P:NHapi.Base.Validation.IRule.Description" />
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.SizeRule.SectionReference">
            <summary>
            Gets the section reference.
            </summary>
            <seealso cref="P:NHapi.Base.Validation.IRule.SectionReference" />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.SizeRule.correct(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.SizeRule.Correct(System.String)">
            <inheritdoc />
            <remarks>
            Does nothing and simply returns the value passed in.
            If what you wanted was to trim the value to the max size, you should
            make a separate rule for that.
            </remarks>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.SizeRule.test(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.SizeRule.Test(System.String)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace">
            <summary>
            Performs no validation but removes leading whitespace in the correct() method.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.2 $ updated on $Date: 2005/06/14 20:16:01 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.Description">
            <summary>
            Gets the rule description.
            </summary>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.SectionReference">
            <summary>
            Gets the section reference.
            </summary>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.correct(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.Correct(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.test(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.TrimLeadingWhitespace.Test(System.String)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Validation.Implementation.ValidationContextImpl">
            <summary>
            A default implementation of. <code>ValidationContext</code>.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.5 $ updated on $Date: 2005/06/27 22:42:18 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.ValidationContextImpl.PrimitiveRuleBindings">
            <returns> a List of. <code>RuleBinding</code>s for. <code>PrimitiveTypeRule</code>s.
            </returns>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.ValidationContextImpl.MessageRuleBindings">
            <returns> a List of. <code>RuleBinding</code>s for. <code>MessageRule</code>s.
            </returns>
        </member>
        <member name="P:NHapi.Base.Validation.Implementation.ValidationContextImpl.EncodingRuleBindings">
            <returns> a List of. <code>RuleBinding</code>s for. <code>EncodingRule</code>s.
            </returns>
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.getPrimitiveRules(System.String,System.String,NHapi.Base.Model.IPrimitive)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.GetPrimitiveRules(System.String,System.String,NHapi.Base.Model.IPrimitive)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.getMessageRules(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.GetMessageRules(System.String,System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.getEncodingRules(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:NHapi.Base.Validation.Implementation.ValidationContextImpl.GetEncodingRules(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="T:NHapi.Base.Validation.IPrimitiveTypeRule">
            <summary>
            A rule that applies to a primitive datatype.
            </summary>
            <author>Bryan Tripp.</author>
        </member>
        <member name="M:NHapi.Base.Validation.IPrimitiveTypeRule.Correct(System.String)">
            <summary>
            Optionally performs an automatic correction on given data to make it
            conform (eg trims leading whitespace). This is to be called prior to
            test(). If no corrections are performed, the original value is returned.
            </summary>
            <param name="originalValue">An original value to be corrected.</param>
            <returns>A corrected version of the given value.</returns>
        </member>
        <member name="M:NHapi.Base.Validation.IPrimitiveTypeRule.Test(System.String)">
            <summary>
            Tests the given string against the criteria defined by this
            rule -- returns true if it passes the test, false otherwise.
            </summary>
        </member>
        <member name="T:NHapi.Base.Validation.IRule">
            <summary> <p>A testable rule to which HL7 messages (at least certain specific message) should conform.
            This is the central interface of the new HAPI validation model (as of HAPI 0.4).
            Previously, the only run-time message validation HAPI performs is within the
            setValue() methods of the Primitive datatype classes.  For example when you
            called setValue() on a DT an exception was thrown if the String arg was not in
            the correct DT format.  This method served well initially but left us with the
            following limitations:
            <ol><li>Sometimes validation is inappropriate (e.g. some of the standard rules, like phone
            number format, don't make sense in some regions).  </li>
            <li>Couldn't add further optional constraints (such as all timestamps must have
            a time zone).  </li>
            <li>Couldn't turn off validation to improve performance. </li>
            <li>Other forms of validation (e.g. conformance profiles, standard DTDs) were
            not covered.  </li></ol></p>
            <p>Thus the new validation model is broader in scope, and is based on validation rules
            implemented as Rule objects, which can be configured to run or not, as needed, depending on
            run-time configuration.</p>
            <p>There are three kinds of rules:
            <ol><li>DataTypeRule: Called when the values of simple datatypes are set, like
            the existing hard-coded datatype validations (e.g. TNFollowsNorthAmericanFormat).</li>
            <li>MessageRule: Called when complete message content is to be checked on a
            parsed message (e.g. conformance profile). </li>
            <li>EncodingRule: Applied to an encoded message (e.g. validation against a
            2.xml Schema, a rule that prohibits empty tags, etc.).</li>
            </ol></p>
            </summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="P:NHapi.Base.Validation.IRule.Description">
            <summary> Returns a text description of the rule.  This description may be used as a message
            in exceptions generated if validation against the rule fails, or in a user
            interface for rule configuration.
            </summary>
        </member>
        <member name="P:NHapi.Base.Validation.IRule.SectionReference">
            <summary> A string indicating the section of the HL7 standard from which this rule
            is derived (if applicable).  Like the description, this may be used in an exception
            message or configuration UI.
            </summary>
        </member>
        <member name="T:NHapi.Base.Validation.IValidationContext">
            <summary>
            A set of rules for message validation.
            </summary>
            <author><a href="mailto:bryan.tripp@uhn.on.ca">Bryan Tripp</a></author>
            <version>
            $Revision: 1.4 $ updated on $Date: 2005/06/27 22:42:18 $ by $Author: bryan_tripp $.
            </version>
        </member>
        <member name="M:NHapi.Base.Validation.IValidationContext.GetPrimitiveRules(System.String,System.String,NHapi.Base.Model.IPrimitive)">
            <param name="theVersion">an HL7 version (eg "2.1").
            </param>
            <param name="theTypeName">a primitive datatype name (eg "ST").
            </param>
            <param name="theType">the Primitive being validated.
            </param>
            <returns> active rules for checking the given type in the given version.
            </returns>
        </member>
        <member name="M:NHapi.Base.Validation.IValidationContext.GetMessageRules(System.String,System.String,System.String)">
            <param name="theVersion">an HL7 version (eg "2.1").
            </param>
            <param name="theMessageType">a value valid for MSH-9-1.
            </param>
            <param name="theTriggerEvent">a value valid fro MSH-9-2.
            </param>
            <returns> the active rules that apply to message of the given version, message type,
            and trigger event.
            </returns>
        </member>
        <member name="M:NHapi.Base.Validation.IValidationContext.GetEncodingRules(System.String,System.String)">
            <param name="theVersion">an HL7 version (eg "2.1").
            </param>
            <param name="theEncoding">an encoding name (eg "VB", "XML).
            </param>
            <returns> the active encoding rules that apply to the given version and encoding.
            </returns>
        </member>
        <member name="T:NHapi.Base.Validation.MessageValidator">
             <summary> Validation utilities for parsed and encoded messages.
            
             </summary>
             <author>  Bryan Tripp.
             </author>
        </member>
        <member name="M:NHapi.Base.Validation.MessageValidator.#ctor(NHapi.Base.Validation.IValidationContext,System.Boolean)">
            <param name="theContext">context that determines which validation rules apply.
            </param>
            <param name="theFailOnErrorFlag">
            </param>
        </member>
        <member name="M:NHapi.Base.Validation.MessageValidator.Validate(NHapi.Base.Model.IMessage)">
            <param name="message">a parsed message to validate (note that MSH-9-1 and MSH-9-2 must be valued).
            </param>
            <returns> true if the message is OK.
            </returns>
            <throws>  HL7Exception if there is at least one error and this validator is set to fail on errors. </throws>
        </member>
        <member name="M:NHapi.Base.Validation.MessageValidator.Validate(System.String,System.Boolean,System.String)">
            <param name="message">an ER7 or XML encoded message to validate.
            </param>
            <param name="isXML">true if XML, false if ER7.
            </param>
            <param name="version">HL7 version (e.g. "2.2") to which the message belongs.
            </param>
            <returns> true if the message is OK.
            </returns>
            <throws>  HL7Exception if there is at least one error and this validator is set to fail on errors. </throws>
        </member>
        <member name="T:NHapi.Base.Validation.ValidationException">
            <summary> A failure to validate against a rule.  </summary>
            <author>  Bryan Tripp.
            </author>
        </member>
        <member name="M:NHapi.Base.Validation.ValidationException.#ctor">
            <summary> Creates a new instance of. <code>ValidationException</code> without detail message.</summary>
        </member>
        <member name="M:NHapi.Base.Validation.ValidationException.#ctor(System.String,System.Exception)">
            <param name="message">
            </param>
            <param name="cause">
            </param>
        </member>
        <member name="M:NHapi.Base.Validation.ValidationException.#ctor(System.String)">
            <summary> Constructs an instance of. <code>ValidationException</code> with the specified detail message.</summary>
            <param name="msg">the detail message.
            </param>
        </member>
    </members>
</doc>
